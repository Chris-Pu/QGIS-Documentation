# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, QGIS project
# This file is distributed under the same license as the QGIS Documentation
# Project package.
# 
# Translators:
# Dinko Eichin <dinkoeichin@gmail.com>, 2019
# Fran Raga <FRANKA1986@gmail.com>, 2017-2018
# Fran Raga <FRANKA1986@gmail.com>, 2017,2019
# Marco Peralta <map.zamora@gmail.com>, 2015
# Néstor, 2020
# YoViajo, 2016
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-06 11:48+0100\n"
"PO-Revision-Date: 2020-03-12 11:10+0000\n"
"Last-Translator: Néstor\n"
"Language-Team: Spanish (http://www.transifex.com/qgis/qgis-documentation/language/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:9
msgid "Using Vector Layers"
msgstr "Usar capas vectoriales"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:14
msgid ""
"This section summarizes various actions that can be done with vector layers."
msgstr "Esta sección sumariza varias acciones que pueden ser realizadas con las capas vectoriales"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:16
msgid ""
"Most work here is based on the methods of the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class."
msgstr "La mayor parte del trabajo acá expuesto está basado en los métodos de la clase  :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:22
msgid "Retrieving information about attributes"
msgstr "Recuperando información sobre atributos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:24
msgid ""
"You can retrieve information about the fields associated with a vector layer"
" by calling :meth:`fields() <qgis.core.QgsVectorLayer.fields>` on a "
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object:"
msgstr "Puede recuperar información sobre los campos asociados a una capa vectorial llamando el método :meth:`fields() <qgis.core.QgsVectorLayer.fields>`  de un objeto de la clase :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` "

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:37
msgid "Iterating over Vector Layer"
msgstr "Iterando sobre la capa vectorial"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:39
msgid ""
"Iterating over the features in a vector layer is one of the most common "
"tasks. Below is an example of the simple basic code to perform this task and"
" showing some information about each feature. The ``layer`` variable is "
"assumed to have a :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object."
msgstr "a iteración de las entidades de una capa vectorial es una de las tareas más comunes. A continuación se muestra un ejemplo del código básico simple para realizar esta tarea y mostrar cierta información sobre cada característica. Se supone que la variable ''layer'' tiene un objeto :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:88
msgid "Selecting features"
msgstr "Seleccionando objetos espaciales"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:90
msgid ""
"In QGIS desktop, features can be selected in different ways: the user can "
"click on a feature, draw a rectangle on the map canvas or use an expression "
"filter. Selected features are normally highlighted in a different color "
"(default is yellow) to draw user's attention on the selection."
msgstr "En el escritorio QGIS, las entidades se pueden seleccionar de diferentes maneras: el usuario puede hacer clic en una entidad, dibujar un rectángulo en el lienzo del mapa o utilizar un filtro de expresión. Las entidades seleccionadas normalmente se resaltan en un color diferente (el valor predeterminado es el amarillo) para llamar la atención del usuario sobre la selección."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:95
msgid ""
"Sometimes it can be useful to programmatically select features or to change "
"the default color."
msgstr "A veces puede ser útil seleccionar características mediante programación o cambiar el color predeterminado."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:98
msgid ""
"To select all the features, the :meth:`selectAll() "
"<qgis.core.QgsVectorLayer.selectAll>` method can be used:"
msgstr "Para seleccionar todas las características, se puede utilizar el método :meth:`selectAll() <qgis.core.QgsVectorLayer.selectAll>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:106
msgid ""
"To select using an expression, use the :meth:`selectByExpression() "
"<qgis.core.QgsVectorLayer.selectByExpression>` method:"
msgstr "Para seleccionar usando una expresión, utilice el método :meth:`selectByExpression() <qgis.core.QgsVectorLayer.selectByExpression>` "

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:115
msgid ""
"To change the selection color you can use :meth:`setSelectionColor() "
"<qgis.gui.QgsMapCanvas.setSelectionColor>` method of :class:`QgsMapCanvas "
"<qgis.gui.QgsMapCanvas>` as shown in the following example:"
msgstr "Para cambiar el color de selección puede utilizar el método :meth:`setSelectionColor() <qgis.gui.QgsMapCanvas.setSelectionColor>` de :class:`QgsMapCanvas <qgis.gui.QgsMapCanvas>` como se muestra en el ejemplo siguiente:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:123
msgid ""
"To add features to the selected features list for a given layer, you can "
"call :meth:`select() <qgis.core.QgsVectorLayer.select>` passing to it the "
"list of features IDs:"
msgstr "Para agregar entidades a la lista de entidades seleccionada para una capa determinada, puede llamar a :meth:`select() <qgis.core.QgsVectorLayer.select>` pasándole la lista de identificadores de las entidades:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:138
msgid "To clear the selection:"
msgstr "Para borrar la selección:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:145
msgid "Accessing attributes"
msgstr "Accediendo a atributos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:147
msgid "Attributes can be referred to by their name:"
msgstr "Los atributos pueden ser referidos por su nombre:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:153
msgid ""
"Alternatively, attributes can be referred to by index. This is a bit faster "
"than using the name. For example, to get the first attribute:"
msgstr "Alternativamente, los atributos pueden ser referidos por índice. Esto es un poco más rápido que usar el nombre. Por ejemplo, para obtener el primer atributo:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:162
msgid "Iterating over selected features"
msgstr "Iterando sobre rasgos seleccionados"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:164
msgid ""
"If you only need selected features, you can use the "
":meth:`selectedFeatures() <qgis.core.QgsVectorLayer.selectedFeatures>` "
"method from the vector layer:"
msgstr "Si solo necesita entidades seleccionadas, puede utilizar el método  :meth:`selectedFeatures() <qgis.core.QgsVectorLayer.selectedFeatures>` de la capa vectorial:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:176
msgid "Iterating over a subset of features"
msgstr "Iterando sobre un subconjunto de rasgos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:178
msgid ""
"If you want to iterate over a given subset of features in a layer, such as "
"those within a given area, you have to add a :class:`QgsFeatureRequest "
"<qgis.core.QgsFeatureRequest>` object to the :meth:`getFeatures() "
"<qgis.core.QgsVectorLayer.getFeatures>` call. Here's an example:"
msgstr "Si desea iterar sobre un subconjunto determinado de entidades de una capa, como las que se encuentran en un área determinada, debe agregar un objeto :class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` a la llamada de :meth:`getFeatures() <qgis.core.QgsVectorLayer.getFeatures>`. Este es un ejemplo:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:191
msgid ""
"For the sake of speed, the intersection is often done only using feature’s "
"bounding box. There is however a flag ``ExactIntersect`` that makes sure "
"that only intersecting features will be returned:"
msgstr "En aras de la velocidad, la intersección a menudo se realiza solo con el cuadro delimitador de la entidad. Sin embargo, hay una bandera ``ExactIntersect`` que se asegura de que solo se devolverán las entidades que se cruzan:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:199
msgid ""
"With :meth:`setLimit() <qgis.core.QgsFeatureRequest.setLimit>` you can limit"
" the number of requested features. Here's an example:"
msgstr "Con :meth:`setLimit() <qgis.core.QgsFeatureRequest.setLimit>` puede limitar el número de entidades solicitadas. Este es un ejemplo:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:209
msgid ""
"If you need an attribute-based filter instead (or in addition) of a spatial "
"one like shown in the examples above, you can build a :class:`QgsExpression "
"<qgis.core.QgsExpression>` object and pass it to the "
":class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` constructor. Here's"
" an example:"
msgstr "Si necesita un filtro basado en atributos en su lugar (o además) de uno espacial como se muestra en los ejemplos anteriores, puede crear un objeto :class:`QgsExpression <qgis.core.QgsExpression>` y pasarlo al constructor :class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>`. Este es un ejemplo:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:222
msgid ""
"See :ref:`expressions` for the details about the syntax supported by "
":class:`QgsExpression <qgis.core.QgsExpression>`."
msgstr "Consulte :ref:`expressions` para obtener detalles sobre la sintaxis admitida por :class:`QgsExpression <qgis.core.QgsExpression>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:224
msgid ""
"The request can be used to define the data retrieved for each feature, so "
"the iterator returns all features, but returns partial data for each of "
"them."
msgstr "La solicitud se puede utilizar para definir los datos recuperados para cada entidad, por lo que el iterador devuelve todas las entidades, pero devuelve datos parciales para cada una de ellas."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:249
msgid "Modifying Vector Layers"
msgstr "Modificación de capas vectoriales"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:251
msgid ""
"Most vector data providers support editing of layer data. Sometimes they "
"support just a subset of possible editing actions. Use the "
":meth:`capabilities() <qgis.core.QgsVectorDataProvider.capabilities>` "
"function to find out what set of functionality is supported."
msgstr "La mayoría de los proveedores de datos vectoriales admiten la edición de datos de capa. A veces solo admiten un subconjunto de posibles acciones de edición. Utilice la función :meth:`capabilities() <qgis.core.QgsVectorDataProvider.capabilities>` para averiguar qué conjunto de funcionalidad es compatible."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:263
msgid ""
"For a list of all available capabilities, please refer to the :class:`API "
"Documentation of QgsVectorDataProvider <qgis.core.QgsVectorDataProvider>`."
msgstr "Para obtener una lista de todas las capacidades disponibles, consulte la documentación :class:`API Documentation of QgsVectorDataProvider <qgis.core.QgsVectorDataProvider>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:267
msgid ""
"To print layer's capabilities textual description in a comma separated list "
"you can use :meth:`capabilitiesString() "
"<qgis.core.QgsVectorDataProvider.capabilitiesString>` as in the following "
"example:"
msgstr "Para imprimir la descripción textual de las capacidades de las capas en una lista separada por comas, puede utilizar :meth:`capabilitiesString() <qgis.core.QgsVectorDataProvider.capabilitiesString>` como en el ejemplo siguiente:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:280
msgid ""
"By using any of the following methods for vector layer editing, the changes "
"are directly committed to the underlying data store (a file, database etc). "
"In case you would like to do only temporary changes, skip to the next "
"section that explains how to do :ref:`modifications with editing buffer "
"<editing-buffer>`."
msgstr "Mediante el uso de cualquiera de los métodos siguientes para la edición de capas vectoriales, los cambios se confirman directamente en el almacén de datos subyacente (un archivo, una base de datos, etc.). En caso de que desee realizar solo cambios temporales, vaya a la siguiente sección que explica cómo hacer :ref:`modificaciones con la edición de cambios de búfer <editing-buffer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:288
msgid ""
"If you are working inside QGIS (either from the console or from a plugin), "
"it might be necessary to force a redraw of the map canvas in order to see "
"the changes you've done to the geometry, to the style or to the attributes:"
msgstr "Si está trabajando dentro de QGIS (ya sea desde la consola o desde un complemento), podría ser necesario forzar un redibujo del lienzo del mapa para ver los cambios que ha realizado en la geometría, en el estilo o en los atributos:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:303
msgid "Add Features"
msgstr "Añadir Entidades"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:305
msgid ""
"Create some :class:`QgsFeature <qgis.core.QgsFeature>` instances and pass a "
"list of them to provider's :meth:`addFeatures() "
"<qgis.core.QgsVectorDataProvider.addFeatures>` method. It will return two "
"values: result (true/false) and list of added features (their ID is set by "
"the data store)."
msgstr "Cree algunas instancias de :class:`QgsFeature <qgis.core.QgsFeature>` y pase una lista de ellas al método del proveedor :meth:`addFeatures() <qgis.core.QgsVectorDataProvider.addFeatures>` Devolverá dos valores: resultado (verdadero/falso) y lista de características agregadas (su identificador lo establece el almacén de datos)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:309
msgid ""
"To set up the attributes of the feature, you can either initialize the "
"feature passing a :class:`QgsFields <qgis.core.QgsFields>` object (you can "
"obtain that from the :meth:`fields() <qgis.core.QgsVectorLayer.fields>` "
"method of the vector layer) or call :meth:`initAttributes() "
"<qgis.core.QgsFeature.initAttributes>` passing the number of fields you want"
" to be added."
msgstr "Para configurar los atributos de la entidad, puede inicializar la entidad pasando un objeto :class:`QgsFields <qgis.core.QgsFields>` (puede obtenerlo del método :meth:`fields() <qgis.core.QgsVectorLayer.fields>` de la capa vectorial) o llamar a :meth:`initAttributes() <qgis.core.QgsFeature.initAttributes>` pasando el número de campos que desea agregar."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:328
msgid "Delete Features"
msgstr "Borrar Entidades"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:330
msgid "To delete some features, just provide a list of their feature IDs."
msgstr "Para eliminar algunas entidades, solo tiene que proporcionar una lista de identificaciones de entidades."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:338
msgid "Modify Features"
msgstr "Modificar los objetos espaciales"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:340
msgid ""
"It is possible to either change feature's geometry or to change some "
"attributes. The following example first changes values of attributes with "
"index 0 and 1, then it changes the feature's geometry."
msgstr "Es posible cambiar la geometría de la entidad o cambiar algunos atributos. En el ejemplo siguiente se cambian primero los valores de los atributos con los índices 0 y 1 y, a continuación, se cambia la geometría de la entidad."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:357
msgid "**Favor QgsVectorLayerEditUtils class for geometry-only edits**"
msgstr "**Favorecer la clase QgsVectorLayerEditUtils para ediciones de solo geometría**"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:359
msgid ""
"If you only need to change geometries, you might consider using the "
":class:`QgsVectorLayerEditUtils <qgis.core.QgsVectorLayerEditUtils>` which "
"provides some useful methods to edit geometries (translate, insert or move "
"vertex, etc.)."
msgstr "Si solo necesita cambiar geometrías, podría considerar el uso de :class:`QgsVectorLayerEditUtils <qgis.core.QgsVectorLayerEditUtils>` que proporciona algunos métodos útiles para editar geometrías (trasladar, insertar o mover vértices, etc.)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:366
msgid "Modifying Vector Layers with an Editing Buffer"
msgstr "Modificación de capas vectoriales con un búfer de edición"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:368
msgid ""
"When editing vectors within QGIS application, you have to first start "
"editing mode for a particular layer, then do some modifications and finally "
"commit (or rollback) the changes. All the changes you make are not written "
"until you commit them --- they stay in layer's in-memory editing buffer. It "
"is possible to use this functionality also programmatically --- it is just "
"another method for vector layer editing that complements the direct usage of"
" data providers. Use this option when providing some GUI tools for vector "
"layer editing, since this will allow user to decide whether to "
"commit/rollback and allows the usage of undo/redo. When changes are "
"commited, all changes from the editing buffer are saved to data provider."
msgstr "Al editar vectores dentro de la aplicación QGIS, primero tiene que comenzar el modo de edición para una capa en particular, luego hacer algunas modificaciones y finalmente confirmar (o revertir) los cambios. Todos los cambios que realice no se escribirán hasta que los confirme --- ellos permanecen en el búfer de edición en memoria de la capa. Es posible utilizar esta funcionalidad también mediante programación --- es sólo otro método para la edición de capas vectoriales que complementa el uso directo de proveedores de datos. Utilice esta opción al proporcionar algunas herramientas GUI para la edición de capas vectoriales, ya que esto permitirá al usuario decidir si desea confirmar/revertir y permite el uso de deshacer/rehacer. Cuando se confirman los cambios, todos los cambios del búfer de edición se guardan en el proveedor de datos."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:379
msgid ""
"The methods are similar to the ones we have seen in the provider, but they "
"are called on the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object "
"instead."
msgstr "Los métodos son similares a los que hemos visto en el proveedor, pero se llaman en el objeto :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` en su lugar."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:383
msgid ""
"For these methods to work, the layer must be in editing mode. To start the "
"editing mode, use the :meth:`startEditing() "
"<qgis.core.QgsVectorLayer.startEditing>` method. To stop editing, use the "
":meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` or "
":meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` methods. The first "
"one will commit all your changes to the data source, while the second one "
"will discard them and will not modify the data source at all."
msgstr "Para que estos métodos funcionen, la capa debe estar en modo de edición. Para iniciar el modo de edición, utilice el método :meth:`startEditing() <qgis.core.QgsVectorLayer.startEditing>` Para detener la edición, utilice los métodos :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` o :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>`. El primero confirmará todos los cambios en el origen de datos, mientras que el segundo los descartará y no modificará el origen de datos en absoluto."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:390
msgid ""
"To find out whether a layer is in editing mode, use the :meth:`isEditable() "
"<qgis.core.QgsVectorLayer.isEditable>` method."
msgstr "Para averiguar si una capa está en modo de edición, utilice el método :meth:`isEditable() <qgis.core.QgsVectorLayer.isEditable>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:393
msgid ""
"Here you have some examples that demonstrate how to use these editing "
"methods."
msgstr "Aquí tiene algunos ejemplos que muestran cómo utilizar estos métodos de edición."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:414
msgid ""
"In order to make undo/redo work properly, the above mentioned calls have to "
"be wrapped into undo commands. (If you do not care about undo/redo and want "
"to have the changes stored immediately, then you will have easier work by "
":ref:`editing with data provider <editing>`.)"
msgstr "Para hacer que deshacer/rehacer trabaje correctamente, las llamadas mencionadas arriba tienen que ser envueltas en los comandos undo. (Si no le importa deshacer/rehacer y desea que los cambios se almacenen inmediatamente, entonces tendrá un trabajo más fácil por :ref:`editando con proveedor de datos <editing>`.)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:419
msgid "Here is how you can use the undo functionality:"
msgstr "Así es cómo usted puede utilizar la funcionalidad de deshacer:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:435
msgid ""
"The :meth:`beginEditCommand() <qgis.core.QgsVectorLayer.beginEditCommand>` "
"method will create an internal \"active\" command and will record subsequent"
" changes in vector layer. With the call to :meth:`endEditCommand() "
"<qgis.core.QgsVectorLayer.endEditCommand>` the command is pushed onto the "
"undo stack and the user will be able to undo/redo it from GUI. In case "
"something went wrong while doing the changes, the "
":meth:`destroyEditCommand() <qgis.core.QgsVectorLayer.destroyEditCommand>` "
"method will remove the command and rollback all changes done while this "
"command was active."
msgstr "El método :meth:`beginEditCommand() <qgis.core.QgsVectorLayer.beginEditCommand>` creará un comando interno de \"activo\" y registrará los cambios posteriores en la capa vectorial. Con la llamada a el comando :meth:`endEditCommand() <qgis.core.QgsVectorLayer.endEditCommand>` se inserta en la pila de deshacer y el usuario podrá deshacer/rehacerlo desde la GUI. En caso de que algo saliera mal al realizar los cambios, el método :meth:`destroyEditCommand() <qgis.core.QgsVectorLayer.destroyEditCommand>` quitará el comando y revertirá todos los cambios realizados mientras este comando estaba activo."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:442
msgid ""
"You can also use the :code:`with edit(layer)`-statement to wrap commit and "
"rollback into a more semantic code block as shown in the example below:"
msgstr "También puede utilizar la instrucción :code:`with edit(layer)`- para encapsular la confirmación y la reversión en un bloque de código más semántico, como se muestra en el ejemplo siguiente:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:453
msgid ""
"This will automatically call :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` in the end. If any exception "
"occurs, it will :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` all "
"the changes. In case a problem is encountered within :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` (when the method returns False) a "
":class:`QgsEditError <qgis.core.QgsEditError>` exception will be raised."
msgstr "Esto llamará automáticamente a :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` al final. Si ocurre alguna excepción, hará :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` a todos los cambios. En caso de que se encuentre un problema dentro de :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` (cuando el método devuelve False) se producirá una excepción :class:`QgsEditError <qgis.core.QgsEditError>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:459
msgid "Adding and Removing Fields"
msgstr "Agregando y Removiendo Campos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:461
msgid ""
"To add fields (attributes), you need to specify a list of field definitions."
" For deletion of fields just provide a list of field indexes."
msgstr "Para agregar campos (atributos), usted necesita especificar una lista de definiciones de campo. Para la eliminación de campos sólo proporcione una lista de índices de campo."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:476
msgid ""
"After adding or removing fields in the data provider the layer's fields need"
" to be updated because the changes are not automatically propagated."
msgstr "Después de agregar o quitar campos en el proveedor de datos, los campos de la capa deben actualizarse porque los cambios no se propagan automáticamente."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:483
msgid "**Directly save changes using** ``with`` **based command**"
msgstr "**Guarde directamente los cambios usando el comando basado en** ``with`` "

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:485
msgid ""
"Using ``with edit(layer):`` the changes will be commited automatically "
"calling :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` at "
"the end. If any exception occurs, it will :meth:`rollBack() "
"<qgis.core.QgsVectorLayer.rollBack>` all the changes. See :ref:`editing-"
"buffer`."
msgstr "Usando ``with edit(layer):`` los cambios se confirmarán automáticamente llamando a :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` al final. Si se produce alguna excepción, hará un :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` de todos los cambios. Consulte :ref:`editing-buffer`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:493
msgid "Using Spatial Index"
msgstr "Usar índice espacial"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:495
msgid ""
"Spatial indexes can dramatically improve the performance of your code if you"
" need to do frequent queries to a vector layer. Imagine, for instance, that "
"you are writing an interpolation algorithm, and that for a given location "
"you need to know the 10 closest points from a points layer, in order to use "
"those point for calculating the interpolated value. Without a spatial index,"
" the only way for QGIS to find those 10 points is to compute the distance "
"from each and every point to the specified location and then compare those "
"distances. This can be a very time consuming task, especially if it needs to"
" be repeated for several locations. If a spatial index exists for the layer,"
" the operation is much more effective."
msgstr "Los índices espaciales pueden mejorar drásticamente el rendimiento del código si necesita realizar consultas frecuentes en una capa vectorial. Imagine, por ejemplo, que está escribiendo un algoritmo de interpolación, y que para una ubicación determinada necesita conocer los 10 puntos más cercanos de una capa de puntos, con el fin de utilizar esos puntos para calcular el valor interpolado. Sin un índice espacial, la única manera de que QGIS encuentre esos 10 puntos es calcular la distancia desde todos y cada uno de los puntos hasta la ubicación especificada y luego comparar esas distancias. Esto puede ser una tarea que consume mucho tiempo, especialmente si necesita repetirse para varias ubicaciones. Si existe un índice espacial para la capa, la operación es mucho más efectiva."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:506
msgid ""
"Think of a layer without a spatial index as a telephone book in which "
"telephone numbers are not ordered or indexed. The only way to find the "
"telephone number of a given person is to read from the beginning until you "
"find it."
msgstr "Piense en una capa sin un índice espacial como una guía telefónica en la que los números de teléfono no se ordenan ni indexan. La única manera de encontrar el número de teléfono de una persona determinada es leer desde el principio hasta que lo encuentres."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:510
msgid ""
"Spatial indexes are not created by default for a QGIS vector layer, but you "
"can create them easily. This is what you have to do:"
msgstr "Los índices espaciales no se crean de forma predeterminada para una capa vectorial QGIS, pero puede crearlos fácilmente. Esto es lo que tienes que hacer:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:513
msgid ""
"create spatial index using the :meth:`QgsSpatialIndex() "
"<qgis.core.QgsVectorLayer.beginEditCommand>` class:"
msgstr "crear índice espacial utilizando la clase :meth:`QgsSpatialIndex() <qgis.core.QgsVectorLayer.beginEditCommand>`:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:519
msgid ""
"add features to index --- index takes :class:`QgsFeature "
"<qgis.core.QgsFeature>` object and adds it to the internal data structure. "
"You can create the object manually or use one from a previous call to the "
"provider's :meth:`getFeatures() "
"<qgis.core.QgsVectorDataProvider.getFeatures>` method."
msgstr "agregar entidades al índice --- el índice toma el objeto :class:`QgsFeature <qgis.core.QgsFeature>` y lo agrega a la estructura de datos interna. Puede crear el objeto manualmente o usar uno de una llamada anterior al método :meth:`getFeatures() <qgis.core.QgsVectorDataProvider.getFeatures>` del proveedor."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:528
msgid ""
"alternatively, you can load all features of a layer at once using bulk "
"loading"
msgstr "alternativamente, puede cargar todas las entidades de una capa a la vez utilizando la carga masiva"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:534
msgid "once spatial index is filled with some values, you can do some queries"
msgstr "Una vez que el índice espacial se llena con algunos valores, puede realizar algunas consultas"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:548
msgid "Creating Vector Layers"
msgstr "Creación de capas vectoriales"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:550
msgid "There are several ways to generate a vector layer dataset:"
msgstr "Hay varias maneras de generar un dataset de capa vectorial:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:552
msgid ""
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` class: A "
"convenient class for writing vector files to disk, using either a static "
"call to :meth:`writeAsVectorFormat() "
"<qgis.core.QgsVectorFileWriter.writeAsVectorFormat>` which saves the whole "
"vector layer or creating an instance of the class and issue calls to "
":meth:`addFeature() <qgis.core.QgsVectorFileWriter.addFeature>`. This class "
"supports all the vector formats that OGR supports (GeoPackage, Shapefile, "
"GeoJSON, KML and others)."
msgstr "la clase :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` class: Una clase cómoda para escribir archivos vectoriales en el disco, utilizando una llamada estática a  :meth:`writeAsVectorFormat() <qgis.core.QgsVectorFileWriter.writeAsVectorFormat>` que guarda toda la capa vectorial o crea una instancia de la clase y emite llamadas a :meth:`addFeature() <qgis.core.QgsVectorFileWriter.addFeature>`. Esta clase admite todos los formatos vectoriales que Soporta OGR (GeoPackage, Shapefile, GeoJSON, KML y otros)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:560
msgid ""
"the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` class: instantiates a"
" data provider that interprets the supplied path (url) of the data source to"
" connect to and access the data. It can be used to create temporary, memory-"
"based layers (``memory``) and connect to OGR datasets (``ogr``), databases "
"(``postgres``, ``spatialite``, ``mysql``, ``mssql``) and more (``wfs``, "
"``gpx``, ``delimitedtext``...)."
msgstr "la clase :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`: crea una instancia de un proveedor de datos que interpreta la ruta de acceso proporcionada (url) del origen de datos para conectarse a los datos y tener acceso a ellos. Se puede utilizar para crear capas temporales basadas en memoria (``memory``) y conectarse a datasets OGR (``ogr``), bases de datos (``postgres``, ``spatialite``, ``mysql``, ``mssql``) y más (``wfs``, ``gpx``, ``delimitedtext``...)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:569
msgid ""
"From an instance of :class:`QgsVectorFileWriter "
"<qgis.core.QgsVectorFileWriter>`"
msgstr "Desde una instancia de :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:590
msgid ""
"The third (mandatory) parameter specifies output text encoding. Only some "
"drivers need this for correct operation - Shapefile is one of them (other "
"drivers will ignore this parameter). Specifying the correct encoding is "
"important if you are using international (non US-ASCII) characters."
msgstr "El tercer parámetro (obligatorio) especifica la codificación de texto de salida. Sólo algunos controladores necesitan esto para el funcionamiento correcto - Shapefile es uno de ellos (otros controladores ignorarán este parámetro). Especificar la codificación correcta es importante si utiliza caracteres internacionales (no US-ASCII)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:613
msgid ""
"You can also convert fields to make them compatible with different formats "
"by using the  :class:`FieldValueConverter "
"<qgis.core.QgsVectorFileWriter.FieldValueConverter>`. For example, to "
"convert array variable types (e.g. in Postgres) to a text type, you can do "
"the following:"
msgstr "También puede convertir campos para que sean compatibles con formatos diferentes usando :class:`FieldValueConverter <qgis.core.QgsVectorFileWriter.FieldValueConverter>`. Por ejemplo, para convertir tipos de variable matriz (por ejemplo, en Postgres) en un tipo texto, puede hacer lo siguiente:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:650
msgid ""
"A destination CRS may also be specified --- if a valid instance of "
":class:`QgsCoordinateReferenceSystem "
"<qgis.core.QgsCoordinateReferenceSystem>` is passed as the fourth parameter,"
" the layer is transformed to that CRS."
msgstr "También se puede especificar un CRS de destino --- si se pasa una instancia válida de :class:`QgsCoordinateReferenceSystem <qgis.core.QgsCoordinateReferenceSystem>` como cuarto parámetro, la capa se transforma a ese CRS."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:654
msgid ""
"For valid driver names please call the :meth:`supportedFiltersAndFormats "
"<qgis.core.QgsVectorFileWriter.supportedFiltersAndFormats>` method or "
"consult the `supported formats by OGR`_ --- you should pass the value in the"
" \"Code\" column as the driver name."
msgstr "Para los nombres de controlador válidos, llame al método :meth:`supportedFiltersAndFormats <qgis.core.QgsVectorFileWriter.supportedFiltersAndFormats>` o consulte los 'formatos admitidos por OGR`_ ---  debe pasar el valor en la columna \"Código\" como el nombre del controlador."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:659
msgid ""
"Optionally you can set whether to export only selected features, pass "
"further driver-specific options for creation or tell the writer not to "
"create attributes... There are a number of other (optional) parameters; see "
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` "
"documentation for details."
msgstr "Opcionalmente, puede establecer si desea exportar solo las entidades seleccionadas, pasar más opciones específicas del controlador para la creación o indicar al escritor que no cree atributos... Hay una serie de otros parámetros (opcionales); consulte la documentación de :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` para más detalles."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:666
msgid "Directly from features"
msgstr "Directamente desde las funciones"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:705
msgid "From an instance of :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`"
msgstr "Desde una instancia de :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:707
msgid ""
"Among all the data providers supported by the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class, let's focus on the memory-based layers. "
"Memory provider is intended to be used mainly by plugin or 3rd party app "
"developers. It does not store data on disk, allowing developers to use it as"
" a fast backend for some temporary layers."
msgstr "Entre todos los proveedores de datos admitidos por la clase :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`, vamos a centrarnos en las capas basadas en memoria. Proveedor de memoria está destinado a ser utilizado principalmente por plugins o desarrolladores de aplicaciones de 3as partes. No almacena datos en el disco, lo que permite a los desarrolladores utilizarlos como un backend rápido para algunas capas temporales."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:713
msgid "The provider supports string, int and double fields."
msgstr "El proveedor admite los campos string, int y double."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:715
msgid ""
"The memory provider also supports spatial indexing, which is enabled by "
"calling the provider's :meth:`createSpatialIndex() "
"<qgis.core.QgsVectorDataProvider.createSpatialIndex>` function. Once the "
"spatial index is created you will be able to iterate over features within "
"smaller regions faster (since it's not necessary to traverse all the "
"features, only those in specified rectangle)."
msgstr "El proveedor de memoria también admite la indexación espacial, que se habilita llamando a la función :meth:`createSpatialIndex() <qgis.core.QgsVectorDataProvider.createSpatialIndex>` del proveedor. Una vez creado el índice espacial, podrá recorrer iterando sobre las entidades dentro de regiones más pequeñas más rápido (ya que no es necesario atravesar todas las entidades, solo las del rectángulo especificado).."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:722
msgid ""
"A memory provider is created by passing ``\"memory\"`` as the provider "
"string to the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` "
"constructor."
msgstr "Un proveedor de memoria se crea pasando ``\"memory\"`` como la cadena del proveedor al constructor :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:725
msgid ""
"The constructor also takes a URI defining the geometry type of the layer, "
"one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
"``\"MultiPoint\"``, ``\"MultiLineString\"``, ``\"MultiPolygon\"`` or "
"``\"None\"``."
msgstr "El constructor también toma un URI que define el tipo de geometría de la capa, uno de:  ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, ``\"MultiPoint\"``, ``\"MultiLineString\"``, ``\"MultiPolygon\"`` o ``\"None\"``."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:729
msgid ""
"The URI can also specify the coordinate reference system, fields, and "
"indexing of the memory provider in the URI. The syntax is:"
msgstr "El URI también puede especificar el sistema de referencia de coordenadas, los campos y la indexación del proveedor de memoria en el URI. La sintaxis es:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:735
msgid "crs=definition"
msgstr "crs=definición"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:733
msgid ""
"Specifies the coordinate reference system, where definition may be any of "
"the forms accepted by :meth:`QgsCoordinateReferenceSystem.createFromString "
"<qgis.core.QgsCoordinateReferenceSystem.createFromString>`"
msgstr "Especifica el sistema de referencia de coordenadas, donde la definition puede ser cualquiera de las formas aceptadas por :meth:`QgsCoordinateReferenceSystem.createFromString <qgis.core.QgsCoordinateReferenceSystem.createFromString>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:738
msgid "index=yes"
msgstr "index=yes"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:738
msgid "Specifies that the provider will use a spatial index"
msgstr "Especifica que el proveedor utilizará un índice espacial"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:743
msgid "field=name:type(length,precision)"
msgstr "campo"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:741
msgid ""
"Specifies an attribute of the layer.  The attribute has a name, and "
"optionally a type (integer, double, or string), length, and precision. There"
" may be multiple field definitions."
msgstr "Especifica un atributo de la capa. El atributo tiene un nombre y, opcionalmente, un tipo (entero, doble o cadena), longitud y precisión. Puede haber múltiples definiciones de campo"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:745
msgid "The following example of a URI incorporates all these options"
msgstr "El siguiente ejemplo de una URI incorpora todas estas opciones"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:751
msgid ""
"The following example code illustrates creating and populating a memory "
"provider"
msgstr "El siguiente código de ejemplo ilustra como crear y rellenar un proveedor de memoria"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:777
msgid "Finally, let's check whether everything went well"
msgstr "Finalmente, vamos a comprobar si todo salió bien"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:795
msgid "Appearance (Symbology) of Vector Layers"
msgstr "Apariencia (Simbología) de capas vectoriales"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:797
msgid ""
"When a vector layer is being rendered, the appearance of the data is given "
"by **renderer** and **symbols** associated with the layer.  Symbols are "
"classes which take care of drawing of visual representation of features, "
"while renderers determine what symbol will be used for a particular feature."
msgstr "Cuando una capa vectorial se representa, la apariencia de los datos se indica por **renderer** y **símbolos** asociados a la capa. Los símbolos son clases que se encargan del dibujo de la representación visual de las entidades, mientras que los renderizadores determinan qué símbolo se utilizará para una entidad determinada."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:802
msgid "The renderer for a given layer can be obtained as shown below:"
msgstr "El renderizador para una capa determinada se puede obtener como se muestra a continuación:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:808
msgid "And with that reference, let us explore it a bit"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:814
msgid ""
"There are several known renderer types available in the QGIS core library:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Type"
msgstr "Tipo"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Class"
msgstr "Clase"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Description"
msgstr "Descripción"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid "singleSymbol"
msgstr "singleSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid ":class:`QgsSingleSymbolRenderer <qgis.core.QgsSingleSymbolRenderer>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid "Renders all features with the same symbol"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid "categorizedSymbol"
msgstr "categorizedSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid ""
":class:`QgsCategorizedSymbolRenderer "
"<qgis.core.QgsCategorizedSymbolRenderer>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid "Renders features using a different symbol for each category"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid "graduatedSymbol"
msgstr "graduatedSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid ""
":class:`QgsGraduatedSymbolRenderer  <qgis.core.QgsGraduatedSymbolRenderer>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid "Renders features using a different symbol for each range of values"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:826
msgid ""
"There might be also some custom renderer types, so never make an assumption "
"there are just these types. You can query the application's "
":class:`QgsRendererRegistry <qgis.core.QgsRendererRegistry>` to find out "
"currently available renderers:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:845
msgid ""
"It is possible to obtain a dump of a renderer contents in text form --- can "
"be useful for debugging"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:855
msgid "Single Symbol Renderer"
msgstr "Representador de Símbolo Único"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:857
msgid ""
"You can get the symbol used for rendering by calling :meth:`symbol() "
"<qgis.core.QgsSingleSymbolRenderer.symbol>` method and change it with "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` method "
"(note for C++ devs: the renderer takes ownership of the symbol.)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:861
msgid ""
"You can change the symbol used by a particular vector layer by calling "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` passing an"
" instance of the appropriate symbol instance. Symbols for *point*, *line* "
"and *polygon* layers can be created by calling the :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` function of the corresponding "
"classes :class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>`, "
":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` and :class:`QgsFillSymbol "
"<qgis.core.QgsFillSymbol>`."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:868
msgid ""
"The dictionary passed to :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` sets the style properties of the "
"symbol."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:871
msgid ""
"For example you can replace the symbol used by a particular **point** layer "
"by calling :meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>`"
" passing an instance of a :class:`QgsMarkerSymbol "
"<qgis.core.QgsMarkerSymbol>`, as in the following code example:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:882
msgid ""
"``name`` indicates the shape of the marker, and can be any of the following:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:884
msgid "``circle``"
msgstr "``circle``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:885
msgid "``square``"
msgstr "``cuadrado``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:886
msgid "``cross``"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:887
msgid "``rectangle``"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:888
msgid "``diamond``"
msgstr "``Diamante``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:889
msgid "``pentagon``"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:890
msgid "``triangle``"
msgstr "``triángulo``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:891
msgid "``equilateral_triangle``"
msgstr "``equilateral_triangle``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:892
msgid "``star``"
msgstr "``star``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:893
msgid "``regular_star``"
msgstr "``regular_star``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:894
msgid "``arrow``"
msgstr "``arrow``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:895
msgid "``filled_arrowhead``"
msgstr "``filled_arrowhead``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:896
msgid "``x``"
msgstr "``x``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:899
msgid ""
"To get the full list of properties for the first symbol layer of a symbol "
"instance you can follow the example code:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:925
msgid "This can be useful if you want to alter some properties:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:944
msgid "Categorized Symbol Renderer"
msgstr "Representador de símbolo categorizado"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:946
msgid ""
"When using a categorized renderer, you can query and set the attribute that "
"is used for classification: use the :meth:`classAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.classAttribute>` and "
":meth:`setClassAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.setClassAttribute>` methods."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:949
msgid "To get a list of categories"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:956
msgid ""
"Where :meth:`value() <qgis.core.QgsRendererCategory.value>` is the value "
"used for discrimination between categories, :meth:`label() "
"<qgis.core.QgsRendererCategory.label>` is a text used for category "
"description and :meth:`symbol() <qgis.core.QgsRendererCategory.symbol>` "
"method returns the assigned symbol."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:960
msgid ""
"The renderer usually stores also original symbol and color ramp which were "
"used for the classification: :meth:`sourceColorRamp() "
"<qgis.core.QgsCategorizedSymbolRenderer.sourceColorRamp>` and "
":meth:`sourceSymbol() <qgis.core.QgsCategorizedSymbolRenderer.sourceSymbol>`"
" methods."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:966
msgid "Graduated Symbol Renderer"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:968
msgid ""
"This renderer is very similar to the categorized symbol renderer described "
"above, but instead of one attribute value per class it works with ranges of "
"values and thus can be used only with numerical attributes."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:972
msgid "To find out more about ranges used in the renderer"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:984
msgid ""
"you can again use the :meth:`classAttribute "
"<qgis.core.QgsGraduatedSymbolRenderer.classAttribute>` (to find the "
"classification attribute name), :meth:`sourceSymbol "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceSymbol>` and "
":meth:`sourceColorRamp "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceColorRamp>` methods. "
"Additionally there is the :meth:`mode "
"<qgis.core.QgsGraduatedSymbolRenderer.mode>` method which determines how the"
" ranges were created: using equal intervals, quantiles or some other method."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:993
msgid ""
"If you wish to create your own graduated symbol renderer you can do so as "
"illustrated in the example snippet below (which creates a simple two class "
"arrangement)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1037
msgid "Working with Symbols"
msgstr "Trabajo con Símbolos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1039
msgid ""
"For representation of symbols, there is :class:`QgsSymbol "
"<qgis.core.QgsSymbol>` base class with three derived classes:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1042
msgid ""
":class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>` --- for point features"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1043
msgid ":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` --- for line features"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1044
msgid ""
":class:`QgsFillSymbol <qgis.core.QgsFillSymbol>` --- for polygon features"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1046
msgid ""
"**Every symbol consists of one or more symbol layers** (classes derived from"
" :class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>`). The symbol layers do "
"the actual rendering, the symbol class itself serves only as a container for"
" the symbol layers."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1050
msgid ""
"Having an instance of a symbol (e.g. from a renderer), it is possible to "
"explore it: the :meth:`type <qgis.core.QgsSymbol.type>` method says whether "
"it is a marker, line or fill symbol. There is a :meth:`dump "
"<qgis.core.QgsSymbol.dump>` method which returns a brief description of the "
"symbol. To get a list of symbol layers:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1062
msgid ""
"To find out symbol's color use :meth:`color <qgis.core.QgsSymbol.color>` "
"method and :meth:`setColor <qgis.core.QgsSymbol.setColor>` to change its "
"color. With marker symbols additionally you can query for the symbol size "
"and rotation with the :meth:`size <qgis.core.QgsMarkerSymbol.size>` and "
":meth:`angle <qgis.core.QgsMarkerSymbol.angle>` methods. For line symbols "
"the :meth:`width <qgis.core.QgsLineSymbol.width>` method returns the line "
"width."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1067
msgid "Size and width are in millimeters by default, angles are in degrees."
msgstr "De forma predeterminada el tamaño y ancho están en milímetros, los ángulos en grados."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1072
msgid "Working with Symbol Layers"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1074
msgid ""
"As said before, symbol layers (subclasses of :class:`QgsSymbolLayer "
"<qgis.core.QgsSymbolLayer>`) determine the appearance of the features.  "
"There are several basic symbol layer classes for general use. It is possible"
" to implement new symbol layer types and thus arbitrarily customize how "
"features will be rendered. The :meth:`layerType() "
"<qgis.core.QgsSymbolLayer.layerType>` method uniquely identifies the symbol "
"layer class --- the basic and default ones are ``SimpleMarker``, "
"``SimpleLine`` and ``SimpleFill`` symbol layers types."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1081
msgid ""
"You can get a complete list of the types of symbol layers you can create for"
" a given symbol layer class with the following code:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1092
msgid "Output:"
msgstr "Salida:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1104
msgid ""
"The :class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` class"
" manages a database of all available symbol layer types."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1107
msgid ""
"To access symbol layer data, use its :meth:`properties() "
"<qgis.core.QgsSymbolLayer.properties>` method that returns a key-value "
"dictionary of properties which determine the appearance. Each symbol layer "
"type has a specific set of properties that it uses. Additionally, there are "
"the generic methods :meth:`color <qgis.core.QgsSymbol.color>`, :meth:`size "
"<qgis.core.QgsMarkerSymbol.size>`, :meth:`angle "
"<qgis.core.QgsMarkerSymbol.angle>` and :meth:`width "
"<qgis.core.QgsLineSymbol.width>`, with their setter counterparts. Of course "
"size and angle are available only for marker symbol layers and width for "
"line symbol layers."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1119
msgid "Creating Custom Symbol Layer Types"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1121
msgid ""
"Imagine you would like to customize the way how the data gets rendered. You "
"can create your own symbol layer class that will draw the features exactly "
"as you wish. Here is an example of a marker that draws red circles with "
"specified radius"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1161
msgid ""
"The :meth:`layerType <qgis.core.QgsSymbolLayer.layerType>` method determines"
" the name of the symbol layer; it has to be unique among all symbol layers. "
"The :meth:`properties <qgis.core.QgsSymbolLayer.properties>` method is used "
"for persistence of attributes. The :meth:`clone "
"<qgis.core.QgsSymbolLayer.clone>` method must return a copy of the symbol "
"layer with all attributes being exactly the same. Finally there are "
"rendering methods: :meth:`startRender "
"<qgis.core.QgsSymbolLayer.startRender>` is called before rendering the first"
" feature, :meth:`stopRender <qgis.core.QgsSymbolLayer.stopRender>` when the "
"rendering is done, and :meth:`renderPoint "
"<qgis.core.QgsMarkerSymbolLayer.renderPoint>` is called to do the rendering."
" The coordinates of the point(s) are already transformed to the output "
"coordinates."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1173
msgid ""
"For polylines and polygons the only difference would be in the rendering "
"method: you would use :meth:`renderPolyline "
"<qgis.core.QgsLineSymbolLayer.renderPolyline>` which receives a list of "
"lines, while :meth:`renderPolygon "
"<qgis.core.QgsFillSymbolLayer.renderPolygon>` receives a list of points on "
"the outer ring as the first parameter and a list of inner rings (or None) as"
" a second parameter."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1181
msgid ""
"Usually it is convenient to add a GUI for setting attributes of the symbol "
"layer type to allow users to customize the appearance: in case of our "
"example above we can let user set circle radius. The following code "
"implements such widget"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1219
msgid ""
"This widget can be embedded into the symbol properties dialog. When the "
"symbol layer type is selected in symbol properties dialog, it creates an "
"instance of the symbol layer and an instance of the symbol layer widget. "
"Then it calls the :meth:`setSymbolLayer "
"<qgis.gui.QgsSymbolLayerWidget.setSymbolLayer>` method to assign the symbol "
"layer to the widget. In that method the widget should update the UI to "
"reflect the attributes of the symbol layer. The :meth:`symbolLayer "
"<qgis.gui.QgsSymbolLayerWidget.symbolLayer>` method is used to retrieve the "
"symbol layer again by the properties dialog to use it for the symbol."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1229
msgid ""
"On every change of attributes, the widget should emit the :any:`changed() "
"<qgis.gui.QgsSymbolLayerWidget.changed>` signal to let the properties dialog"
" update the symbol preview."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1233
msgid ""
"Now we are missing only the final glue: to make QGIS aware of these new "
"classes. This is done by adding the symbol layer to registry. It is possible"
" to use the symbol layer also without adding it to the registry, but some "
"functionality will not work: e.g. loading of project files with the custom "
"symbol layers or inability to edit the layer's attributes in GUI."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1239
msgid "We will have to create metadata for the symbol layer"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1260
msgid ""
"You should pass layer type (the same as returned by the layer) and symbol "
"type (marker/line/fill) to the constructor of the parent class. The "
":meth:`createSymbolLayer() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` method takes "
"care of creating an instance of symbol layer with attributes specified in "
"the `props` dictionary. And there is the :meth:`createSymbolLayerWidget() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` method "
"which returns the settings widget for this symbol layer type."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1268
msgid ""
"The last step is to add this symbol layer to the registry --- and we are "
"done."
msgstr "El último pase es adicionar esta capa símbolo al registro --- y estamos listos."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1274
msgid "Creating Custom Renderers"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1276
msgid ""
"It might be useful to create a new renderer implementation if you would like"
" to customize the rules how to select symbols for rendering of features. "
"Some use cases where you would want to do it: symbol is determined from a "
"combination of fields, size of symbols changes depending on current scale "
"etc."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1281
msgid ""
"The following code shows a simple custom renderer that creates two marker "
"symbols and chooses randomly one of them for every feature"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1337
msgid ""
"The constructor of the parent :class:`QgsFeatureRenderer "
"<qgis.core.QgsFeatureRenderer>` class needs a renderer name (which has to be"
" unique among renderers). The :meth:`symbolForFeature "
"<qgis.core.QgsFeatureRenderer.symbolForFeature>` method is the one that "
"decides what symbol will be used for a particular feature. "
":meth:`startRender <qgis.core.QgsFeatureRenderer.startRender>` and "
":meth:`stopRender <qgis.core.QgsFeatureRenderer.stopRender>` take care of "
"initialization/finalization of symbol rendering. The :meth:`usedAttributes "
"<qgis.core.QgsFeatureRenderer.usedAttributes>` method can return a list of "
"field names that the renderer expects to be present. Finally, the "
":meth:`clone <qgis.core.QgsFeatureRenderer.clone>` method should return a "
"copy of the renderer."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1348
msgid ""
"Like with symbol layers, it is possible to attach a GUI for configuration of"
" the renderer. It has to be derived from :class:`QgsRendererWidget "
"<qgis.gui.QgsRendererWidget>`. The following sample code creates a button "
"that allows the user to set the first symbol"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1382
msgid ""
"The constructor receives instances of the active layer "
"(:class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`), the global style "
"(:class:`QgsStyle <qgis.core.QgsStyle>`) and the current renderer. If there "
"is no renderer or the renderer has different type, it will be replaced with "
"our new renderer, otherwise we will use the current renderer (which has "
"already the type we need). The widget contents should be updated to show "
"current state of the renderer. When the renderer dialog is accepted, the "
"widget's :meth:`renderer <qgis.gui.QgsRendererWidget.renderer>` method is "
"called to get the current renderer --- it will be assigned to the layer."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1392
msgid ""
"The last missing bit is the renderer metadata and registration in registry, "
"otherwise loading of layers with the renderer will not work and user will "
"not be able to select it from the list of renderers. Let us finish our "
"RandomRenderer example"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1412
msgid ""
"Similarly as with symbol layers, abstract metadata constructor awaits "
"renderer name, name visible for users and optionally name of renderer's "
"icon. The :meth:`createRenderer "
"<qgis.core.QgsRendererAbstractMetadata.createRenderer>` method passes a "
":class:`QDomElement` instance that can be used to restore the renderer's "
"state from the DOM tree. The :meth:`createRendererWidget "
"<qgis.core.QgsRendererAbstractMetadata.createRendererWidget>` method creates"
" the configuration widget. It does not have to be present or can return "
"``None`` if the renderer does not come with GUI."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1421
msgid ""
"To associate an icon with the renderer you can assign it in the "
":class:`QgsRendererAbstractMetadata <qgis.core.QgsRendererAbstractMetadata>`"
" constructor as a third (optional) argument --- the base class constructor "
"in the RandomRendererMetadata :func:`__init__` function becomes"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1434
msgid ""
"The icon can also be associated at any later time using the :meth:`setIcon "
"<qgis.core.QgsRendererAbstractMetadata.setIcon>` method of the metadata "
"class. The icon can be loaded from a file (as shown above) or can be loaded "
"from a `Qt resource <https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 "
"includes .qrc compiler for Python)."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1442
msgid "Further Topics"
msgstr "Más Temas"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1445
msgid "**TODO:**"
msgstr "**PENDIENTE:**"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1447
msgid "creating/modifying symbols"
msgstr "crear/modificar símbolos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1448
msgid "working with style (:class:`QgsStyle <qgis.core.QgsStyle>`)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1449
msgid ""
"working with color ramps (:class:`QgsColorRamp <qgis.core.QgsColorRamp>`)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1450
msgid "exploring symbol layer and renderer registries"
msgstr ""

#~ msgid ""
#~ "You can retrieve information about the fields associated with a vector layer"
#~ " by calling :func:`pendingFields` on a :class:`QgsVectorLayer` instance::"
#~ msgstr ""

#~ msgid ""
#~ "Starting from QGIS 2.12 there is also a :func:`fields()` in "
#~ ":class:`QgsVectorLayer` which is an alias to :func:`pendingFields`."
#~ msgstr ""

#~ msgid ""
#~ "In QGIS desktop, features can be selected in different ways, the user can "
#~ "click on a feature, draw a rectangle on the map canvas or use an expression "
#~ "filter. Selected features are normally highlighted in a different color "
#~ "(default is yellow) to draw user's attention on the selection. Sometimes can"
#~ " be useful to programmatically select features or to change the default "
#~ "color."
#~ msgstr ""

#~ msgid ""
#~ "To change the selection color you can use :func:`setSelectionColor()` method"
#~ " of :class:`QgsMapCanvas` as shown in the following example::"
#~ msgstr ""

#~ msgid ""
#~ "To add add features to the selected features list for a given layer, you can"
#~ " call :func:`setSelectedFeatures()` passing to it the list of features IDs::"
#~ msgstr ""

#~ msgid "To clear the selection, just pass an empty list::"
#~ msgstr ""

#~ msgid ""
#~ "Iterating over the features in a vector layer is one of the most common "
#~ "tasks. Below is an example of the simple basic code to perform this task and"
#~ " showing some information about each feature. the ``layer`` variable is "
#~ "assumed to have a :class:`QgsVectorLayer` object"
#~ msgstr ""

#~ msgid "Attributes can be referred to by their name."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, attributes can be referred to by index. This is will be a bit"
#~ " faster than using the name. For example, to get the first attribute:"
#~ msgstr ""

#~ msgid ""
#~ "if you only need selected features, you can use the :func:`selectedFeatures`"
#~ " method from vector layer:"
#~ msgstr ""

#~ msgid "Another option is the Processing :func:`features` method:"
#~ msgstr ""

#~ msgid ""
#~ "By default, this will iterate over all the features in the layer, in case "
#~ "there is no selection, or over the selected features otherwise. Note that "
#~ "this behavior can be changed in the Processing options to ignore selections."
#~ msgstr ""

#~ msgid ""
#~ "If you want to iterate over a given subset of features in a layer, such as "
#~ "those within a given area, you have to add a :obj:`QgsFeatureRequest` object"
#~ " to the :func:`getFeatures()` call. Here's an example"
#~ msgstr ""

#~ msgid ""
#~ "With :func:`setLimit()` you can limit the number of requested features. "
#~ "Here's an example"
#~ msgstr ""

#~ msgid ""
#~ "If you need an attribute-based filter instead (or in addition) of a spatial "
#~ "one like shown in the examples above, you can build an :obj:`QgsExpression` "
#~ "object and pass it to the :obj:`QgsFeatureRequest` constructor. Here's an "
#~ "example"
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`expressions` for the details about the syntax supported by "
#~ ":class:`QgsExpression`."
#~ msgstr ""

#~ msgid "**Speed features request**"
#~ msgstr ""

#~ msgid ""
#~ "If you only need a subset of the attributes or you don't need the geometry "
#~ "information, you can significantly increase the **speed** of the features "
#~ "request by using ``QgsFeatureRequest.NoGeometry`` flag or specifying a "
#~ "subset of attributes (possibly empty) like shown in the example above."
#~ msgstr ""

#~ msgid ""
#~ "Most vector data providers support editing of layer data. Sometimes they "
#~ "support just a subset of possible editing actions. Use the "
#~ ":func:`capabilities` function to find out what set of functionality is "
#~ "supported"
#~ msgstr ""

#~ msgid ""
#~ "For a list of all available capabilities, please refer to the `API "
#~ "Documentation of QgsVectorDataProvider "
#~ "<http://qgis.org/api/classQgsVectorDataProvider.html>`_"
#~ msgstr ""

#~ msgid ""
#~ "To print layer's capabilities textual description in a comma separated list "
#~ "you can use :func:`capabilitiesString` as in the following example:"
#~ msgstr ""

#~ msgid ""
#~ "Create some :class:`QgsFeature` instances and pass a list of them to "
#~ "provider's :func:`addFeatures` method. It will return two values: result "
#~ "(true/false) and list of added features (their ID is set by the data store)."
#~ msgstr ""

#~ msgid ""
#~ "To set up the attributes you can either initialize the feature passing a "
#~ ":class:`QgsFields` instance or call :func:`initAttributes` passing the "
#~ "number of fields you want to be added."
#~ msgstr ""

#~ msgid "To delete some features, just provide a list of their feature IDs"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to either change feature's geometry or to change some "
#~ "attributes. The following example first changes values of attributes with "
#~ "index 0 and 1, then it changes the feature's geometry"
#~ msgstr ""

#~ msgid ""
#~ "If you only need to change geometries, you might consider using the "
#~ ":class:`QgsVectorLayerEditUtils` which provides some of useful methods to "
#~ "edit geometries (translate, insert or move vertex etc.)."
#~ msgstr ""

#~ msgid ""
#~ "Using ``with edit(layer):`` the changes will be commited automatically "
#~ "calling :func:`commitChanges()` at the end. If any exception occurs, it will"
#~ " :func:`rollBack()` all the changes. See :ref:`editing-buffer`."
#~ msgstr ""

#~ msgid ""
#~ "When editing vectors within QGIS application, you have to first start "
#~ "editing mode for a particular layer, then do some modifications and finally "
#~ "commit (or rollback) the changes. All the changes you do are not written "
#~ "until you commit them --- they stay in layer's in-memory editing buffer. It "
#~ "is possible to use this functionality also programmatically --- it is just "
#~ "another method for vector layer editing that complements the direct usage of"
#~ " data providers. Use this option when providing some GUI tools for vector "
#~ "layer editing, since this will allow user to decide whether to "
#~ "commit/rollback and allows the usage of undo/redo. When committing changes, "
#~ "all changes from the editing buffer are saved to data provider."
#~ msgstr ""

#~ msgid ""
#~ "To find out whether a layer is in editing mode, use :func:`isEditable` --- "
#~ "the editing functions work only when the editing mode is turned on. Usage of"
#~ " editing functions"
#~ msgstr ""

#~ msgid ""
#~ "In order to make undo/redo work properly, the above mentioned calls have to "
#~ "be wrapped into undo commands. (If you do not care about undo/redo and want "
#~ "to have the changes stored immediately, then you will have easier work by "
#~ ":ref:`editing with data provider <editing>`.) How to use the undo "
#~ "functionality"
#~ msgstr ""

#~ msgid ""
#~ "The :func:`beginEditCommand` will create an internal \"active\" command and "
#~ "will record subsequent changes in vector layer. With the call to "
#~ ":func:`endEditCommand` the command is pushed onto the undo stack and the "
#~ "user will be able to undo/redo it from GUI. In case something went wrong "
#~ "while doing the changes, the :func:`destroyEditCommand` method will remove "
#~ "the command and rollback all changes done while this command was active."
#~ msgstr ""

#~ msgid ""
#~ "To start editing mode, there is :func:`startEditing()` method, to stop "
#~ "editing there are :func:`commitChanges()` and :func:`rollBack()` --- however"
#~ " normally you should not need these methods and leave this functionality to "
#~ "be triggered by the user."
#~ msgstr ""

#~ msgid ""
#~ "This will automatically call :func:`commitChanges()` in the end. If any "
#~ "exception occurs, it will :func:`rollBack()` all the changes. In case a "
#~ "problem is encountered within :func:`commitChanges()` (when the method "
#~ "returns False) a :class:`QgsEditError` exception will be raised."
#~ msgstr ""

#~ msgid "create spatial index --- the following code creates an empty index"
#~ msgstr ""

#~ msgid ""
#~ "add features to index --- index takes :class:`QgsFeature` object and adds it"
#~ " to the internal data structure. You can create the object manually or use "
#~ "one from previous call to provider's :func:`nextFeature()`"
#~ msgstr ""

#~ msgid "Writing Vector Layers"
#~ msgstr ""

#~ msgid ""
#~ "You can write vector layer files using :class:`QgsVectorFileWriter` class. "
#~ "It supports any other kind of vector file that OGR supports (shapefiles, "
#~ "GeoJSON, KML and others)."
#~ msgstr ""

#~ msgid "There are two possibilities how to export a vector layer:"
#~ msgstr ""

#~ msgid "from an instance of :class:`QgsVectorLayer`"
#~ msgstr ""

#~ msgid ""
#~ "The third parameter specifies output text encoding. Only some drivers need "
#~ "this for correct operation - shapefiles are one of those --- however in case"
#~ " you are not using international characters you do not have to care much "
#~ "about the encoding. The fourth parameter that we left as ``None`` may "
#~ "specify destination CRS --- if a valid instance of "
#~ ":class:`QgsCoordinateReferenceSystem` is passed, the layer is transformed to"
#~ " that CRS."
#~ msgstr ""

#~ msgid "directly from features"
#~ msgstr ""

#~ msgid "Memory Provider"
#~ msgstr ""

#~ msgid ""
#~ "Memory provider is intended to be used mainly by plugin or 3rd party app "
#~ "developers. It does not store data on disk, allowing developers to use it as"
#~ " a fast backend for some temporary layers."
#~ msgstr ""

#~ msgid ""
#~ "The memory provider also supports spatial indexing, which is enabled by "
#~ "calling the provider's :func:`createSpatialIndex` function. Once the spatial"
#~ " index is created you will be able to iterate over features within smaller "
#~ "regions faster (since it's not necessary to traverse all the features, only "
#~ "those in specified rectangle)."
#~ msgstr ""

#~ msgid ""
#~ "A memory provider is created by passing ``\"memory\"`` as the provider "
#~ "string to the :class:`QgsVectorLayer` constructor."
#~ msgstr ""

#~ msgid ""
#~ "Specifies the coordinate reference system, where definition may be any of "
#~ "the forms accepted by :func:`QgsCoordinateReferenceSystem.createFromString`"
#~ msgstr ""

#~ msgid "The renderer for a given layer can obtained as shown below:"
#~ msgstr ""

#~ msgid "There are several known renderer types available in QGIS core library:"
#~ msgstr ""

#~ msgid ":class:`QgsSingleSymbolRendererV2`"
#~ msgstr ""

#~ msgid ":class:`QgsCategorizedSymbolRendererV2`"
#~ msgstr ""

#~ msgid ":class:`QgsGraduatedSymbolRendererV2`"
#~ msgstr ""

#~ msgid ""
#~ "There might be also some custom renderer types, so never make an assumption "
#~ "there are just these types. You can query :class:`QgsRendererV2Registry` "
#~ "singleton to find out currently available renderers:"
#~ msgstr ""

#~ msgid ""
#~ "You can get the symbol used for rendering by calling :func:`symbol` method "
#~ "and change it with :func:`setSymbol` method (note for C++ devs: the renderer"
#~ " takes ownership of the symbol.)"
#~ msgstr ""

#~ msgid ""
#~ "You can change the symbol used by a particular vector layer by calling "
#~ ":func:`setSymbol()` passing an instance of the appropriate symbol instance. "
#~ "Symbols for *point*, *line* and *polygon* layers can be created by calling "
#~ "the :func:`createSimple` function of the corresponding classes "
#~ ":class:`QgsMarkerSymbolV2`, :class:`QgsLineSymbolV2` and "
#~ ":class:`QgsFillSymbolV2`."
#~ msgstr ""

#~ msgid ""
#~ "The dictionary passed to :func:`createSimple` sets the style properties of "
#~ "the symbol."
#~ msgstr ""

#~ msgid ""
#~ "For example you can replace the symbol used by a particular **point** layer "
#~ "by calling :func:`setSymbol()` passing an instance of a "
#~ ":class:`QgsMarkerSymbolV2` as in the following code example:"
#~ msgstr ""

#~ msgid ""
#~ "To get the full list of properties for the first symbol layer of a simbol "
#~ "instance you can follow the example code:"
#~ msgstr ""

#~ msgid ""
#~ "You can query and set attribute name which is used for classification: use "
#~ ":func:`classAttribute` and :func:`setClassAttribute` methods."
#~ msgstr ""

#~ msgid ""
#~ "Where :func:`value` is the value used for discrimination between categories,"
#~ " :func:`label` is a text used for category description and :func:`symbol` "
#~ "method returns assigned symbol."
#~ msgstr ""

#~ msgid ""
#~ "The renderer usually stores also original symbol and color ramp which were "
#~ "used for the classification: :func:`sourceColorRamp` and "
#~ ":func:`sourceSymbol` methods."
#~ msgstr ""

#~ msgid ""
#~ "For representation of symbols, there is :class:`QgsSymbolV2` base class with"
#~ " three derived classes:"
#~ msgstr ""

#~ msgid ":class:`QgsMarkerSymbolV2` --- for point features"
#~ msgstr ""

#~ msgid ":class:`QgsLineSymbolV2` --- for line features"
#~ msgstr ""

#~ msgid ":class:`QgsFillSymbolV2` --- for polygon features"
#~ msgstr ""

#~ msgid ""
#~ "**Every symbol consists of one or more symbol layers** (classes derived from"
#~ " :class:`QgsSymbolLayerV2`). The symbol layers do the actual rendering, the "
#~ "symbol class itself serves only as a container for the symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "Having an instance of a symbol (e.g. from a renderer), it is possible to "
#~ "explore it: :func:`type` method says whether it is a marker, line or fill "
#~ "symbol. There is a :func:`dump` method which returns a brief description of "
#~ "the symbol. To get a list of symbol layers"
#~ msgstr ""

#~ msgid ""
#~ "To find out symbol's color use :func:`color` method and :func:`setColor` to "
#~ "change its color. With marker symbols additionally you can query for the "
#~ "symbol size and rotation with :func:`size` and :func:`angle` methods, for "
#~ "line symbols there is :func:`width` method returning line width."
#~ msgstr ""

#~ msgid ""
#~ "As said before, symbol layers (subclasses of :class:`QgsSymbolLayerV2`) "
#~ "determine the appearance of the features.  There are several basic symbol "
#~ "layer classes for general use. It is possible to implement new symbol layer "
#~ "types and thus arbitrarily customize how features will be rendered. The "
#~ ":func:`layerType` method uniquely identifies the symbol layer class --- the "
#~ "basic and default ones are SimpleMarker, SimpleLine and SimpleFill symbol "
#~ "layers types."
#~ msgstr ""

#~ msgid ""
#~ "You can get a complete list of the types of symbol layers you can create for"
#~ " a given symbol layer class like this"
#~ msgstr ""

#~ msgid "Output"
#~ msgstr ""

#~ msgid ""
#~ ":class:`QgsSymbolLayerV2Registry` class manages a database of all available "
#~ "symbol layer types."
#~ msgstr ""

#~ msgid ""
#~ "To access symbol layer data, use its :func:`properties` method that returns "
#~ "a key-value dictionary of properties which determine the appearance. Each "
#~ "symbol layer type has a specific set of properties that it uses. "
#~ "Additionally, there are generic methods :func:`color`, :func:`size`, "
#~ ":func:`angle`, :func:`width` with their setter counterparts. Of course size "
#~ "and angle is available only for marker symbol layers and width for line "
#~ "symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "The :func:`layerType` method determines the name of the symbol layer, it has"
#~ " to be unique among all symbol layers. Properties are used for persistence "
#~ "of attributes. :func:`clone` method must return a copy of the symbol layer "
#~ "with all attributes being exactly the same. Finally there are rendering "
#~ "methods: :func:`startRender` is called before rendering first feature, "
#~ ":func:`stopRender` when rendering is done. And :func:`renderPoint` method "
#~ "which does the rendering. The coordinates of the point(s) are already "
#~ "transformed to the output coordinates."
#~ msgstr ""

#~ msgid ""
#~ "For polylines and polygons the only difference would be in the rendering "
#~ "method: you would use :func:`renderPolyline` which receives a list of lines,"
#~ " resp. :func:`renderPolygon` which receives list of points on outer ring as "
#~ "a first parameter and a list of inner rings (or None) as a second parameter."
#~ msgstr ""

#~ msgid ""
#~ "You should pass layer type (the same as returned by the layer) and symbol "
#~ "type (marker/line/fill) to the constructor of parent class. "
#~ ":func:`createSymbolLayer` takes care of creating an instance of symbol layer"
#~ " with attributes specified in the `props` dictionary. (Beware, the keys are "
#~ "QString instances, not \"str\" objects). And there is "
#~ ":func:`createSymbolLayerWidget` method which returns settings widget for "
#~ "this symbol layer type."
#~ msgstr ""

#~ msgid ""
#~ "The constructor of parent :class:`QgsFeatureRendererV2` class needs renderer"
#~ " name (has to be unique among renderers). :func:`symbolForFeature` method is"
#~ " the one that decides what symbol will be used for a particular feature. "
#~ ":func:`startRender` and :func:`stopRender` take care of "
#~ "initialization/finalization of symbol rendering. :func:`usedAttributes` "
#~ "method can return a list of field names that renderer expects to be present."
#~ " Finally :func:`clone` function should return a copy of the renderer."
#~ msgstr ""

#~ msgid ""
#~ "Like with symbol layers, it is possible to attach a GUI for configuration of"
#~ " the renderer. It has to be derived from :class:`QgsRendererV2Widget`. The "
#~ "following sample code creates a button that allows user to set symbol of the"
#~ " first symbol"
#~ msgstr ""

#~ msgid ""
#~ "The constructor receives instances of the active layer "
#~ "(:class:`QgsVectorLayer`), the global style (:class:`QgsStyleV2`) and "
#~ "current renderer. If there is no renderer or the renderer has different "
#~ "type, it will be replaced with our new renderer, otherwise we will use the "
#~ "current renderer (which has already the type we need). The widget contents "
#~ "should be updated to show current state of the renderer. When the renderer "
#~ "dialog is accepted, widget's :func:`renderer` method is called to get the "
#~ "current renderer --- it will be assigned to the layer."
#~ msgstr ""

#~ msgid ""
#~ "To associate an icon with the renderer you can assign it in "
#~ ":class:`QgsRendererV2AbstractMetadata` constructor as a third (optional) "
#~ "argument --- the base class constructor in the RandomRendererMetadata "
#~ ":func:`__init__` function becomes"
#~ msgstr ""

#~ msgid ""
#~ "The icon can be associated also at any later time using :func:`setIcon` "
#~ "method of the metadata class. The icon can be loaded from a file (as shown "
#~ "above) or can be loaded from a `Qt resource "
#~ "<http://qt.nokia.com/doc/4.5/resources.html>`_ (PyQt4 includes .qrc compiler"
#~ " for Python)."
#~ msgstr ""

#~ msgid "working with style (:class:`QgsStyleV2`)"
#~ msgstr ""

#~ msgid "working with color ramps (:class:`QgsVectorColorRampV2`)"
#~ msgstr ""

#~ msgid ""
#~ "rule-based renderer (see `this blogpost <http://snorf.net/blog/2014/03/04"
#~ "/symbology-of-vector-layers-in-qgis-python-plugins>`_)"
#~ msgstr ""

#~ msgid "Here is how you can use the the undo functionality:"
#~ msgstr ""

#~ msgid ""
#~ "add features to index --- index takes :class:`QgsFeature "
#~ "<qgis.core.QgsFeature>` object and adds it to the internal data structure. "
#~ "You can create the object manually or use one from a previous call to "
#~ "provider's :meth:`nextFeature() "
#~ "<qgis.core.QgsVectorDataProvider.nextFeature>`"
#~ msgstr ""

#~ msgid "From an instance of :class:`QgsVectorFileWriter`"
#~ msgstr ""

#~ msgid ""
#~ "The third parameter specifies output text encoding. Only some drivers need "
#~ "this for correct operation (Shapefile is one of those), but if you are not "
#~ "using international characters you do not have to care much about the "
#~ "encoding."
#~ msgstr ""

#~ msgid ""
#~ "The fourth parameter that we left as ``None`` may specify the destination "
#~ "CRS --- if a valid instance of :class:`QgsCoordinateReferenceSystem "
#~ "<qgis.core.QgsCoordinateReferenceSystem>` is passed, the layer is "
#~ "transformed to that CRS."
#~ msgstr ""

#~ msgid ""
#~ "For valid driver names please consult the `supported formats by OGR`_ --- "
#~ "you should pass the value in the \"Code\" column as the driver name. "
#~ "Optionally you can set whether to export only selected features, pass "
#~ "further driver-specific options for creation or tell the writer not to "
#~ "create attributes --- look into the documentation for full syntax."
#~ msgstr ""

#~ msgid "From an instance of :class:`QgsVectorLayer`"
#~ msgstr ""

#~ msgid ""
#~ "you can again use :func:`classAttribute` to find out classification "
#~ "attribute name, :func:`sourceSymbol` and :func:`sourceColorRamp` methods.  "
#~ "Additionally there is :func:`mode` method which determines how the ranges "
#~ "were created: using equal intervals, quantiles or some other method."
#~ msgstr ""

#~ msgid ""
#~ "Having an instance of a symbol (e.g. from a renderer), it is possible to "
#~ "explore it: :meth:`type <qgis.core.QgsSymbol.type>` method says whether it "
#~ "is a marker, line or fill symbol. There is a :meth:`dump "
#~ "<qgis.core.QgsSymbol.dump>` method which returns a brief description of the "
#~ "symbol. To get a list of symbol layers:"
#~ msgstr ""

#~ msgid ""
#~ "To find out symbol's color use :meth:`color <qgis.core.QgsSymbol.color>` "
#~ "method and :meth:`setColor <qgis.core.QgsSymbol.setColor>` to change its "
#~ "color. With marker symbols additionally you can query for the symbol size "
#~ "and rotation with :meth:`size <qgis.core.QgsSymbol.size>` and :meth:`angle "
#~ "<qgis.core.QgsSymbol.angle>` methods, for line symbols there is :meth:`width"
#~ " <qgis.core.QgsSymbol.width>` method returning line width."
#~ msgstr ""

#~ msgid ""
#~ ":class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` class "
#~ "manages a database of all available"
#~ msgstr ""

#~ msgid "symbol layer types."
#~ msgstr ""

#~ msgid ""
#~ "To access symbol layer data, use its :meth:`properties() "
#~ "<qgis.core.QgsSymbolLayer.properties>` method that returns a key-value "
#~ "dictionary of properties which determine the appearance. Each symbol layer "
#~ "type has a specific set of properties that it uses. Additionally, there are "
#~ "generic methods :meth:`color <qgis.core.QgsSymbol.color>`, :meth:`size "
#~ "<qgis.core.QgsSymbol.size>`, :meth:`angle <qgis.core.QgsSymbol.angle>`, "
#~ ":meth:`width <qgis.core.QgsSymbol.width>` with their setter counterparts. Of"
#~ " course size and angle is available only for marker symbol layers and width "
#~ "for line symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "The :meth:`layerType <qgis.core.QgsMarkerSymbolLayer.layerType>` method "
#~ "determines the name of the symbol layer, it has to be unique among all "
#~ "symbol layers. Properties are used for persistence of attributes. "
#~ ":meth:`clone <qgis.core.QgsMarkerSymbolLayer.clone>` method must return a "
#~ "copy of the symbol layer with all attributes being exactly the same. Finally"
#~ " there are rendering methods: :meth:`startRender "
#~ "<qgis.core.QgsMarkerSymbolLayer.startRender>` is called before rendering "
#~ "first feature, :meth:`stopRender "
#~ "<qgis.core.QgsMarkerSymbolLayer.stopRender>` when rendering is done. And "
#~ ":meth:`renderPoint <qgis.core.QgsMarkerSymbolLayer.renderPoint>` method "
#~ "which does the rendering. The coordinates of the point(s) are already "
#~ "transformed to the output coordinates."
#~ msgstr ""

#~ msgid ""
#~ "For polylines and polygons the only difference would be in the rendering "
#~ "method: you would use :meth:`renderPolyline "
#~ "<qgis.core.QgsMarkerSymbolLayer.renderPolyline>` which receives a list of "
#~ "lines, while :meth:`renderPolygon "
#~ "<qgis.core.QgsMarkerSymbolLayer.renderPolygon>` receives list of points on "
#~ "outer ring as a first parameter and a list of inner rings (or None) as a "
#~ "second parameter."
#~ msgstr ""

#~ msgid ""
#~ "This widget can be embedded into the symbol properties dialog. When the "
#~ "symbol layer type is selected in symbol properties dialog, it creates an "
#~ "instance of the symbol layer and an instance of the symbol layer widget. "
#~ "Then it calls :func:`setSymbolLayer` method to assign the symbol layer to "
#~ "the widget. In that method the widget should update the UI to reflect the "
#~ "attributes of the symbol layer. :func:`symbolLayer` function is used to "
#~ "retrieve the symbol layer again by the properties dialog to use it for the "
#~ "symbol."
#~ msgstr ""

#~ msgid ""
#~ "On every change of attributes, the widget should emit :func:`changed()` "
#~ "signal to let the properties dialog update the symbol preview."
#~ msgstr ""

#~ msgid ""
#~ "You should pass layer type (the same as returned by the layer) and symbol "
#~ "type (marker/line/fill) to the constructor of parent class. "
#~ ":meth:`createSymbolLayer() "
#~ "<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` takes care of "
#~ "creating an instance of symbol layer with attributes specified in the "
#~ "`props` dictionary. And there is :meth:`createSymbolLayerWidget() "
#~ "<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` method "
#~ "which returns settings widget for this symbol layer type."
#~ msgstr ""

#~ msgid ""
#~ "The constructor of parent :class:`QgsFeatureRenderer` class needs a renderer"
#~ " name (which has to be unique among renderers). The :func:`symbolForFeature`"
#~ " method is the one that decides what symbol will be used for a particular "
#~ "feature. :func:`startRender` and :func:`stopRender` take care of "
#~ "initialization/finalization of symbol rendering. The :func:`usedAttributes` "
#~ "method can return a list of field names that renderer expects to be present."
#~ " Finally, the :func:`clone` function should return a copy of the renderer."
#~ msgstr ""

#~ msgid ""
#~ "Like with symbol layers, it is possible to attach a GUI for configuration of"
#~ " the renderer. It has to be derived from :class:`QgsRendererWidget`. The "
#~ "following sample code creates a button that allows user to set symbol of the"
#~ " first symbol"
#~ msgstr ""

#~ msgid ""
#~ "The constructor receives instances of the active layer "
#~ "(:class:`QgsVectorLayer`), the global style (:class:`QgsStyle`) and current "
#~ "renderer. If there is no renderer or the renderer has different type, it "
#~ "will be replaced with our new renderer, otherwise we will use the current "
#~ "renderer (which has already the type we need). The widget contents should be"
#~ " updated to show current state of the renderer. When the renderer dialog is "
#~ "accepted, widget's :func:`renderer` method is called to get the current "
#~ "renderer --- it will be assigned to the layer."
#~ msgstr ""

#~ msgid ""
#~ "Similarly as with symbol layers, abstract metadata constructor awaits "
#~ "renderer name, name visible for users and optionally name of renderer's "
#~ "icon. :func:`createRenderer` method passes :class:`QDomElement` instance "
#~ "that can be used to restore renderer's state from DOM tree. "
#~ ":func:`createRendererWidget` method creates the configuration widget. It "
#~ "does not have to be present or can return `None` if the renderer does not "
#~ "come with GUI."
#~ msgstr ""

#~ msgid ""
#~ "To associate an icon with the renderer you can assign it in "
#~ ":class:`QgsRendererAbstractMetadata` constructor as a third (optional) "
#~ "argument --- the base class constructor in the RandomRendererMetadata "
#~ ":func:`__init__` function becomes"
#~ msgstr ""

#~ msgid ""
#~ "The icon can be associated also at any later time using :func:`setIcon` "
#~ "method of the metadata class. The icon can be loaded from a file (as shown "
#~ "above) or can be loaded from a `Qt resource "
#~ "<https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 includes .qrc compiler for "
#~ "Python)."
#~ msgstr ""

#~ msgid "|outofdate|"
#~ msgstr ""

#~ msgid ""
#~ "The constructor also takes a URI defining the geometry type of the layer, "
#~ "one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
#~ "``\"MultiPoint\"``, ``\"MultiLineString\"``, or ``\"MultiPolygon\"``."
#~ msgstr ""
