# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, QGIS project
# This file is distributed under the same license as the QGIS Documentation
# Project package.
# 
# Translators:
# Dick Groskamp, 2015-2017,2019
# Milo van der Linden <milo@dogodigi.net>, 2014
# Rodolfo_Jadon, 2014
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-06 11:48+0100\n"
"PO-Revision-Date: 2019-12-06 17:59+0000\n"
"Last-Translator: Dick Groskamp\n"
"Language-Team: Dutch (http://www.transifex.com/qgis/qgis-documentation/language/nl/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"
"Language: nl\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:9
msgid "Using Vector Layers"
msgstr "Vectorlagen gebruiken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:14
msgid ""
"This section summarizes various actions that can be done with vector layers."
msgstr "Dit gedeelte beschrijft verschillende acties die kunnen worden uitgevoerd met vectorlagen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:16
msgid ""
"Most work here is based on the methods of the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class."
msgstr "Het meeste werk hier is gebaseerd op de methoden van de klasse :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:22
msgid "Retrieving information about attributes"
msgstr "Informatie over attributen ophalen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:24
msgid ""
"You can retrieve information about the fields associated with a vector layer"
" by calling :meth:`fields() <qgis.core.QgsVectorLayer.fields>` on a "
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object:"
msgstr "U kunt informatie ophalen over de velden die zijn geassocieerd met een vectorlaag door :meth:`fields() <qgis.core.QgsVectorLayer.fields>`  aan te roepen op een object :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:37
msgid "Iterating over Vector Layer"
msgstr "Itereren over vectorlagen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:39
msgid ""
"Iterating over the features in a vector layer is one of the most common "
"tasks. Below is an example of the simple basic code to perform this task and"
" showing some information about each feature. The ``layer`` variable is "
"assumed to have a :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object."
msgstr "Het doorlopen van de objecten in een vectorlaag is één van de meest voorkomende taken. Hieronder staat een voorbeeld van eenvoudige basiscode om deze taak uit te voeren en enige informatie weer te geven over elk object. Voor de variabele ``layer`` wordt aangenomen dat die een object :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` heeft"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:88
msgid "Selecting features"
msgstr "Objecten selecteren"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:90
msgid ""
"In QGIS desktop, features can be selected in different ways: the user can "
"click on a feature, draw a rectangle on the map canvas or use an expression "
"filter. Selected features are normally highlighted in a different color "
"(default is yellow) to draw user's attention on the selection."
msgstr "In QGIS desktop kunnen objecten op verschillende manieren worden geselecteerd, de gebruiker kan klikken op een object, een rechthoek in het kaartvenster tekenen of een expressie-filter gebruiken. Geselecteerde objecten worden normaal gesproken geaccentueerd in een andere kleur (standaard is geel) om de aandacht van de gebruiker naar de selectie te trekken."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:95
msgid ""
"Sometimes it can be useful to programmatically select features or to change "
"the default color."
msgstr " Soms kan het nuttig zijn om programmatisch objecten te selecteren of om de standaard kleur te wijzigen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:98
msgid ""
"To select all the features, the :meth:`selectAll() "
"<qgis.core.QgsVectorLayer.selectAll>` method can be used:"
msgstr "De methode :meth:`selectAll() <qgis.core.QgsVectorLayer.selectAll>` kan worden gebruikt om alle objecten te selecteren:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:106
msgid ""
"To select using an expression, use the :meth:`selectByExpression() "
"<qgis.core.QgsVectorLayer.selectByExpression>` method:"
msgstr "Gebruik de methode :meth:`selectByExpression() <qgis.core.QgsVectorLayer.selectByExpression>` om te selecteren met een expressie:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:115
msgid ""
"To change the selection color you can use :meth:`setSelectionColor() "
"<qgis.gui.QgsMapCanvas.setSelectionColor>` method of :class:`QgsMapCanvas "
"<qgis.gui.QgsMapCanvas>` as shown in the following example:"
msgstr "U kunt, om de kleur van de selectie te wijzigen, de methode :meth:`setSelectionColor() <qgis.gui.QgsMapCanvas.setSelectionColor>` van :class:`QgsMapCanvas <qgis.gui.QgsMapCanvas>` gebruiken, zoals weergegeven in het volgende voorbeeld:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:123
msgid ""
"To add features to the selected features list for a given layer, you can "
"call :meth:`select() <qgis.core.QgsVectorLayer.select>` passing to it the "
"list of features IDs:"
msgstr "U kunt, om objecten toe te voegen aan de lijst met geselecteerde objecten voor een bepaalde laag, :meth:`select() <qgis.core.QgsVectorLayer.select>` aanroepen, die de lijst met ID's voor de objecten doorgeeft aan de lijst:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:138
msgid "To clear the selection:"
msgstr "De selectie opheffen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:145
msgid "Accessing attributes"
msgstr "Toegang tot attributen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:147
msgid "Attributes can be referred to by their name:"
msgstr "Naar attributen kan worden verwezen door middel van hun naam:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:153
msgid ""
"Alternatively, attributes can be referred to by index. This is a bit faster "
"than using the name. For example, to get the first attribute:"
msgstr "Als alternatief kan naar attributen worden verwezen door middel van een index. Dit is iets sneller dan het gebruiken van de naam. Bijvoorbeeld om het eerste attribuut te krijgen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:162
msgid "Iterating over selected features"
msgstr "Itereren over geselecteerde objecten"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:164
msgid ""
"If you only need selected features, you can use the "
":meth:`selectedFeatures() <qgis.core.QgsVectorLayer.selectedFeatures>` "
"method from the vector layer:"
msgstr "Als u alleen geselecteerde objecten nodig hebt, kunt u de methode :meth:`selectedFeatures() <qgis.core.QgsVectorLayer.selectedFeatures>` gebruiken van de vectorlaag:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:176
msgid "Iterating over a subset of features"
msgstr "Itereren over een deel van de objecten"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:178
msgid ""
"If you want to iterate over a given subset of features in a layer, such as "
"those within a given area, you have to add a :class:`QgsFeatureRequest "
"<qgis.core.QgsFeatureRequest>` object to the :meth:`getFeatures() "
"<qgis.core.QgsVectorLayer.getFeatures>` call. Here's an example:"
msgstr "Wanneer u een deel van de objecten in een laag wilt doorlopen, zoals bijvoorbeeld alleen de objecten in een opgegeven gebied, dan dient een object :class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` te worden toegevoegd aan de aanroep :meth:`getFeatures() <qgis.core.QgsVectorLayer.getFeatures>`. Hier is een voorbeeld:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:191
msgid ""
"For the sake of speed, the intersection is often done only using feature’s "
"bounding box. There is however a flag ``ExactIntersect`` that makes sure "
"that only intersecting features will be returned:"
msgstr "Omwille van de snelheid wordt het kruisen vaak gedaan door alleen het begrenzingsvak van het object te gebruiken. Er is echter een vlag ``ExactIntersect`` dat er voor zorgt dat alleen kruisende objecten zullen worden teruggegeven:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:199
msgid ""
"With :meth:`setLimit() <qgis.core.QgsFeatureRequest.setLimit>` you can limit"
" the number of requested features. Here's an example:"
msgstr "Met :meth:`setLimit() <qgis.core.QgsFeatureRequest.setLimit>` kunt u het aantal gezochte objecten beperken. Hier is een voorbeeld:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:209
msgid ""
"If you need an attribute-based filter instead (or in addition) of a spatial "
"one like shown in the examples above, you can build a :class:`QgsExpression "
"<qgis.core.QgsExpression>` object and pass it to the "
":class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` constructor. Here's"
" an example:"
msgstr "Als u in plaats daarvan een op attributen gebaseerd filter nodig heeft (of als aanvulling) van een ruimtelijke zoals weergegeven in de voorbeelden hierboven, kunt u een object :class:`QgsExpression <qgis.core.QgsExpression>` bouwen en dat doorgeven aan de constructor :class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>`. Hier is een voorbeeld:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:222
msgid ""
"See :ref:`expressions` for the details about the syntax supported by "
":class:`QgsExpression <qgis.core.QgsExpression>`."
msgstr "Bekijk :ref:`expressions` voor de details over de door :class:`QgsExpression <qgis.core.QgsExpression>` ondersteunde syntaxis."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:224
msgid ""
"The request can be used to define the data retrieved for each feature, so "
"the iterator returns all features, but returns partial data for each of "
"them."
msgstr "Het verzoek kan worden gebruikt om de gegevens per opgehaald object te definiëren, zodat de doorloop alle objecten retourneert, maar slechts een deel van de gegevens van elk daarvan teruggeeft."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:249
msgid "Modifying Vector Layers"
msgstr "Vectorlagen bewerken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:251
msgid ""
"Most vector data providers support editing of layer data. Sometimes they "
"support just a subset of possible editing actions. Use the "
":meth:`capabilities() <qgis.core.QgsVectorDataProvider.capabilities>` "
"function to find out what set of functionality is supported."
msgstr "De meeste vector gegevensproviders ondersteunen het bewerken van gegevens van de laag. Soms ondersteunen zij slechts een subset van mogelijke acties voor bewerken. Gebruik de functie :meth:`capabilities() <qgis.core.QgsVectorDataProvider.capabilities>` om uit te zoeken welke set voor functionaliteiten wordt ondersteund."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:263
msgid ""
"For a list of all available capabilities, please refer to the :class:`API "
"Documentation of QgsVectorDataProvider <qgis.core.QgsVectorDataProvider>`."
msgstr "Bekijk, voor een lijst van alle beschikbare capabilities, de :class:`API Documentation of QgsVectorDataProvider <qgis.core.QgsVectorDataProvider>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:267
msgid ""
"To print layer's capabilities textual description in a comma separated list "
"you can use :meth:`capabilitiesString() "
"<qgis.core.QgsVectorDataProvider.capabilitiesString>` as in the following "
"example:"
msgstr "U kunt, om de tekstuele beschrijving van de capabilities van de laag af te drukken naar een kommagescheiden lijst, :meth:`capabilitiesString() <qgis.core.QgsVectorDataProvider.capabilitiesString>` gebruiken, zoals in het volgende voorbeeld:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:280
msgid ""
"By using any of the following methods for vector layer editing, the changes "
"are directly committed to the underlying data store (a file, database etc). "
"In case you would like to do only temporary changes, skip to the next "
"section that explains how to do :ref:`modifications with editing buffer "
"<editing-buffer>`."
msgstr "Bij het gebruiken van de volgende methodes voor het bewerken van vectorlagen worden de wijzigingen direct opgeslagen in de onderliggende gegevensbron (een bestand, database etc.). Voor het geval u slechts tijdelijke wijzigingen wilt uitvoeren, ga dan naar het volgende gedeelte waarin uitgelegd wordt hoe :ref:`aanpassingen kunnen worden uitgevoerd met een bewerkingsbuffer <editing-buffer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:288
msgid ""
"If you are working inside QGIS (either from the console or from a plugin), "
"it might be necessary to force a redraw of the map canvas in order to see "
"the changes you've done to the geometry, to the style or to the attributes:"
msgstr "Als u werkt binnen QGIS (ofwel vanuit de console of vanuit een plug-in), zou het nodig kunnen zijn het opnieuw tekenen van het kaartvenster te forceren om de wijzigingen te kunnen zien die u heeft gemaakt aan de geometrie, aan de stijl of aan de attributen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:303
msgid "Add Features"
msgstr "Objecten toevoegen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:305
msgid ""
"Create some :class:`QgsFeature <qgis.core.QgsFeature>` instances and pass a "
"list of them to provider's :meth:`addFeatures() "
"<qgis.core.QgsVectorDataProvider.addFeatures>` method. It will return two "
"values: result (true/false) and list of added features (their ID is set by "
"the data store)."
msgstr "Maak enkele instances :class:`QgsFeature <qgis.core.QgsFeature>` en geef daar een lijst van door aan de methode :meth:`addFeatures() <qgis.core.QgsVectorDataProvider.addFeatures>` van de provider. Het zal twee waarden teruggeven: resultaat (true/false) en een lijst van toegevoegde objecten (hun ID wordt ingesteld door de opslag van de gegevens)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:309
msgid ""
"To set up the attributes of the feature, you can either initialize the "
"feature passing a :class:`QgsFields <qgis.core.QgsFields>` object (you can "
"obtain that from the :meth:`fields() <qgis.core.QgsVectorLayer.fields>` "
"method of the vector layer) or call :meth:`initAttributes() "
"<qgis.core.QgsFeature.initAttributes>` passing the number of fields you want"
" to be added."
msgstr "U kunt, om de attributen in te stellen, ofwel het object initialiseren door een object :class:`QgsFields <qgis.core.QgsFields>` door te geven (u kunt dat verkrijgen vanuit de methode :meth:`fields() <qgis.core.QgsVectorLayer.fields>` van de vectorlaag) of :meth:`initAttributes() <qgis.core.QgsFeature.initAttributes>` aan te roepen en het aantal velden op te geven die wilt hebben toegevoegd."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:328
msgid "Delete Features"
msgstr "Objecten verwijderen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:330
msgid "To delete some features, just provide a list of their feature IDs."
msgstr "Geef eenvoudigweg een lijst van hun object-ID's op om enkele objecten te verwijderen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:338
msgid "Modify Features"
msgstr "Objecten bewerken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:340
msgid ""
"It is possible to either change feature's geometry or to change some "
"attributes. The following example first changes values of attributes with "
"index 0 and 1, then it changes the feature's geometry."
msgstr "Het is mogelijk om de geometrie van objecten te wijzigen of enkele attributen. Het volgende voorbeeld wijzigt eerst waarden van attributen met de index 0 en 1, en wijzigt dan de geometrie van het object."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:357
msgid "**Favor QgsVectorLayerEditUtils class for geometry-only edits**"
msgstr "**Voorkeur voor klasse QgsVectorLayerEditUtils voor bewerken van alleen de geometrie**"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:359
msgid ""
"If you only need to change geometries, you might consider using the "
":class:`QgsVectorLayerEditUtils <qgis.core.QgsVectorLayerEditUtils>` which "
"provides some useful methods to edit geometries (translate, insert or move "
"vertex, etc.)."
msgstr "Als u alleen geometrieën wilt wijzigen, kunt u overwegen :class:`QgsVectorLayerEditUtils <qgis.core.QgsVectorLayerEditUtils>` te gebruiken wat enkele nuttige methoden verschaft om geometrieën te bewerken (vertalen, invoegen of punten verplaatsen etc.)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:366
msgid "Modifying Vector Layers with an Editing Buffer"
msgstr "Vectorlagen bewerken met een bewerkingsbuffer"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:368
msgid ""
"When editing vectors within QGIS application, you have to first start "
"editing mode for a particular layer, then do some modifications and finally "
"commit (or rollback) the changes. All the changes you make are not written "
"until you commit them --- they stay in layer's in-memory editing buffer. It "
"is possible to use this functionality also programmatically --- it is just "
"another method for vector layer editing that complements the direct usage of"
" data providers. Use this option when providing some GUI tools for vector "
"layer editing, since this will allow user to decide whether to "
"commit/rollback and allows the usage of undo/redo. When changes are "
"commited, all changes from the editing buffer are saved to data provider."
msgstr "Bij het bewerken van vectoren binnen de toepassing QGIS, moet u eerst de modus Bewerken starten voor een bepaalde laag, dan enige aanpassingen te doen en tenslotte de wijzigingen vastleggen (of terugdraaien). Alle aanpassingen die u doet worden niet weggeschreven totdat u ze vastlegt --- zij blijven in de bewerkingsbuffer van het geheugen van de laag. Het is mogelijk om deze functionaliteit ook programmatisch te gebruiken --- het is simpelweg een andere methode voor het bewerken van vectorlagen die het direct gebruik van providers van gegevens aanvult. Gebruik deze optie bij het verschaffen van enkele gereedschappen voor de GUI voor het bewerken van vectorlagen, omdat dit de gebruiker in staat zal stellen te bepalen om vast te leggen/terug te draaien en maakt het gebruiken van Ongedaan maken/Opnieuw mogelijk. Bij het vastleggen van wijzigingen worden alle aanpassingen in de bewerkingsbuffer opgeslagen in de provider van de gegevens."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:379
msgid ""
"The methods are similar to the ones we have seen in the provider, but they "
"are called on the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object "
"instead."
msgstr "De methoden zijn soortgelijk aan die welke we hebben gezien in de provider, maar zij worden in plaats daarvan aangeroepen op het object :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:383
msgid ""
"For these methods to work, the layer must be in editing mode. To start the "
"editing mode, use the :meth:`startEditing() "
"<qgis.core.QgsVectorLayer.startEditing>` method. To stop editing, use the "
":meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` or "
":meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` methods. The first "
"one will commit all your changes to the data source, while the second one "
"will discard them and will not modify the data source at all."
msgstr "De laag met in de modus Bewerken staan om deze methoden te kunnen laten werken. Gebruikt de methode :meth:`startEditing() <qgis.core.QgsVectorLayer.startEditing>` om de modus Bewerken te starten. Gebruik de methoden :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` of :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` om het bewerken te stoppen. De eerste zal al uw wijzigingen vastleggen in de gegevensbron, terwijl de tweede ze zal negeren en de gegevensbron in het geheel niet zal wijzigen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:390
msgid ""
"To find out whether a layer is in editing mode, use the :meth:`isEditable() "
"<qgis.core.QgsVectorLayer.isEditable>` method."
msgstr "Gebruik de methode :meth:`isEditable() <qgis.core.QgsVectorLayer.isEditable>` om te weten te komen of een laag in de modus Bewerken staat."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:393
msgid ""
"Here you have some examples that demonstrate how to use these editing "
"methods."
msgstr "Hier zijn enkele voorbeelden die demonstreren hoe deze methoden voor bewerken te gebruiken."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:414
msgid ""
"In order to make undo/redo work properly, the above mentioned calls have to "
"be wrapped into undo commands. (If you do not care about undo/redo and want "
"to have the changes stored immediately, then you will have easier work by "
":ref:`editing with data provider <editing>`.)"
msgstr "De hierboven vermelde aanroepen moeten zijn opgenomen in opdrachten Ongedaan maken om er voor te zorgen dat Ongedaan maken/Opnieuw juist werkt. (Als Ongedaan maken/Opnieuw voor u niet van belang is en u wilt dat de wijzigingen onmiddellijk worden opgeslagen, dan zult u gemakkelijker werken met :ref:`bewerken met gegevensprovider <editing>`.)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:419
msgid "Here is how you can use the undo functionality:"
msgstr "Hier staat hoe u de functionaliteit Ongedaan maken kunt gebruiken:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:435
msgid ""
"The :meth:`beginEditCommand() <qgis.core.QgsVectorLayer.beginEditCommand>` "
"method will create an internal \"active\" command and will record subsequent"
" changes in vector layer. With the call to :meth:`endEditCommand() "
"<qgis.core.QgsVectorLayer.endEditCommand>` the command is pushed onto the "
"undo stack and the user will be able to undo/redo it from GUI. In case "
"something went wrong while doing the changes, the "
":meth:`destroyEditCommand() <qgis.core.QgsVectorLayer.destroyEditCommand>` "
"method will remove the command and rollback all changes done while this "
"command was active."
msgstr "De methode :meth:`beginEditCommand() <qgis.core.QgsVectorLayer.beginEditCommand>` zal een interne \"actieve\" opdracht maken en zal opvolgende wijzigingen in de vectorlaag opnemen. Met de aanroep naar :meth:`endEditCommand() <qgis.core.QgsVectorLayer.endEditCommand>` wordt de opdracht doorgegeven aan de stapel Ongedaan maken en de gebruiker zal in staat zijn om Ongedaan maken/Opnieuw uit te voeren vanuit de GUI. Voor het geval er iets verkeerd gaat bij het maken van de wijzigingen, zal de methode :meth:`destroyEditCommand() <qgis.core.QgsVectorLayer.destroyEditCommand>` de opdracht verwijderen en de wijzigingen terugdraaien die al werden gemaakt toen deze opdracht actief was."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:442
msgid ""
"You can also use the :code:`with edit(layer)`-statement to wrap commit and "
"rollback into a more semantic code block as shown in the example below:"
msgstr "U kunt ook het argument :code:`with edit(layer)`-gebruiken om commit en rollback in een meer semantisch codeblok op te nemen zoals weergegeven in het voorbeeld hieronder:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:453
msgid ""
"This will automatically call :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` in the end. If any exception "
"occurs, it will :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` all "
"the changes. In case a problem is encountered within :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` (when the method returns False) a "
":class:`QgsEditError <qgis.core.QgsEditError>` exception will be raised."
msgstr "Dit zal aan het einde automatisch :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` aanroepen. Indien er een uitzondering optreedt, zal het :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` alle wijzigingen. In het geval dat een probleem wordt tegengekomen binnen :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` (als de methode False teruggeeft) zal een uitzondering :class:`QgsEditError <qgis.core.QgsEditError>` optreden."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:459
msgid "Adding and Removing Fields"
msgstr "Velden toevoegen en verwijderen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:461
msgid ""
"To add fields (attributes), you need to specify a list of field definitions."
" For deletion of fields just provide a list of field indexes."
msgstr "U moet een lijst met definities voor velden opgeven om velden toe te voegen (attributen). Geef een lijst met indexen van velden op om velden te verwijderen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:476
msgid ""
"After adding or removing fields in the data provider the layer's fields need"
" to be updated because the changes are not automatically propagated."
msgstr "Na het verwijderen of toevoegen van velden in de gegevensprovider moeten de velden van de laag worden bijgewerkt omdat de wijzigingen niet automatisch worden doorgevoerd."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:483
msgid "**Directly save changes using** ``with`` **based command**"
msgstr "**Wijzigingen direct opslaan met op** ``with`` **gebaseerde opdracht**"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:485
msgid ""
"Using ``with edit(layer):`` the changes will be commited automatically "
"calling :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` at "
"the end. If any exception occurs, it will :meth:`rollBack() "
"<qgis.core.QgsVectorLayer.rollBack>` all the changes. See :ref:`editing-"
"buffer`."
msgstr "Gebruiken van ``with edit(layer):`` de wijzigingen zullen automatisch worden vastgelegd door het aanroepen van :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` aan het einde. Indien er een uitzondering optreedt, zal het :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` alle wijzigingen.. Bekijk :ref:`editing-buffer`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:493
msgid "Using Spatial Index"
msgstr "Ruimtelijke index gebruiken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:495
msgid ""
"Spatial indexes can dramatically improve the performance of your code if you"
" need to do frequent queries to a vector layer. Imagine, for instance, that "
"you are writing an interpolation algorithm, and that for a given location "
"you need to know the 10 closest points from a points layer, in order to use "
"those point for calculating the interpolated value. Without a spatial index,"
" the only way for QGIS to find those 10 points is to compute the distance "
"from each and every point to the specified location and then compare those "
"distances. This can be a very time consuming task, especially if it needs to"
" be repeated for several locations. If a spatial index exists for the layer,"
" the operation is much more effective."
msgstr "Ruimtelijke indexen kunnen de uitvoering van uw code enorm verbeteren als u frequent query's moet uitvoeren op een vectorlaag. Stel u bijvoorbeeld voor dat u een algoritme voor interpolatie schrijft, en dat voor een bepaalde locatie u de 10 dichtstbijzijnde punten van een puntenlaag wilt weten om die punten te gebruiken voor het berekenen van de waarde voor de interpolatie. Zonder een ruimtelijke index is de enige manier waarop QGIS die 10 punten kan vinden is door de afstand vanaf elk punt tot de gespecificeerde locatie te berekenen en dan die afstanden te vergelijken. Dit kan een zeer tijdrovende taak zijn, speciaal als het moet worden herhaald voor verschillende locaties. Als er een ruimtelijke index bestaat voor de laag, is de bewerking veel effectiever."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:506
msgid ""
"Think of a layer without a spatial index as a telephone book in which "
"telephone numbers are not ordered or indexed. The only way to find the "
"telephone number of a given person is to read from the beginning until you "
"find it."
msgstr "Denk aan een laag zonder ruimtelijke index als aan een telefoonboek waarin telefoonnummers niet zijn gesorteerd of geïndexeerd. De enige manier om het telefoonnummer van een bepaald persoon te vinden is door vanaf het begin te lezen totdat u het vindt."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:510
msgid ""
"Spatial indexes are not created by default for a QGIS vector layer, but you "
"can create them easily. This is what you have to do:"
msgstr "Ruimtelijke indexen worden niet standaard gemaakt voor een vectorlaag in QGIS, maar u kunt ze eenvoudig maken. Dit is wat u dan moet doen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:513
msgid ""
"create spatial index using the :meth:`QgsSpatialIndex() "
"<qgis.core.QgsVectorLayer.beginEditCommand>` class:"
msgstr "maak een ruimtelijke index met de klasse :meth:`QgsSpatialIndex() <qgis.core.QgsVectorLayer.beginEditCommand>`:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:519
msgid ""
"add features to index --- index takes :class:`QgsFeature "
"<qgis.core.QgsFeature>` object and adds it to the internal data structure. "
"You can create the object manually or use one from a previous call to the "
"provider's :meth:`getFeatures() "
"<qgis.core.QgsVectorDataProvider.getFeatures>` method."
msgstr "voeg objecten aan de index toe --- index neemt object  :class:`QgsFeature <qgis.core.QgsFeature>` en voegt dat toe aan de interne gegevensstructuur. U kunt het object handmatig maken of er een gebruiken uit een eerdere aanroep naar :meth:`getFeatures() <qgis.core.QgsVectorDataProvider.getFeatures>` van de provider."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:528
msgid ""
"alternatively, you can load all features of a layer at once using bulk "
"loading"
msgstr "als alternatief kunt u alle objecten van een laag in één keer laden met behulp van bulk laden"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:534
msgid "once spatial index is filled with some values, you can do some queries"
msgstr "als de ruimtelijke index eenmaal is gevuld met enkele waarden, kunt u enkele query's uitvoeren"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:548
msgid "Creating Vector Layers"
msgstr "Vectorlagen maken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:550
msgid "There are several ways to generate a vector layer dataset:"
msgstr "Er zijn verschillende manieren om een gegevensset uit een vectorlaag te maken:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:552
msgid ""
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` class: A "
"convenient class for writing vector files to disk, using either a static "
"call to :meth:`writeAsVectorFormat() "
"<qgis.core.QgsVectorFileWriter.writeAsVectorFormat>` which saves the whole "
"vector layer or creating an instance of the class and issue calls to "
":meth:`addFeature() <qgis.core.QgsVectorFileWriter.addFeature>`. This class "
"supports all the vector formats that OGR supports (GeoPackage, Shapefile, "
"GeoJSON, KML and others)."
msgstr "de klasse :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>`: Een handige klasse voor het schrijven van vectorbestanden naar schijf, ofwel met een statische aanroep naar :meth:`writeAsVectorFormat() <qgis.core.QgsVectorFileWriter.writeAsVectorFormat>` die de gehele vectorlaag opslaat of een instance van de klasse maken en aanroepen uitvoeren naar :meth:`addFeature() <qgis.core.QgsVectorFileWriter.addFeature>`. Deze klasse ondersteunt alle indelingen voor vector die OGR ondersteunt (GeoPackage, Shapefile, GeoJSON, KML en andere)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:560
msgid ""
"the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` class: instantiates a"
" data provider that interprets the supplied path (url) of the data source to"
" connect to and access the data. It can be used to create temporary, memory-"
"based layers (``memory``) and connect to OGR datasets (``ogr``), databases "
"(``postgres``, ``spatialite``, ``mysql``, ``mssql``) and more (``wfs``, "
"``gpx``, ``delimitedtext``...)."
msgstr "de klasse :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`: instantieert een gegevensprovider die het opgegeven pad (URL) van de gegevensbron interpreteert om te verbinden met en toegang te verschaffen tot de gegevens. Het kan worden gebruikt om tijdelijke, op geheugen gebaseerde lagen (``memory``), te maken  en te verbinden met gegevenssets van OGR (``ogr``), databases (``postgres``, ``spatialite``, ``mysql``, ``mssql``) en meer (``wfs``, ``gpx``, ``delimitedtext``…)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:569
msgid ""
"From an instance of :class:`QgsVectorFileWriter "
"<qgis.core.QgsVectorFileWriter>`"
msgstr "Vanuit een instance van :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:590
msgid ""
"The third (mandatory) parameter specifies output text encoding. Only some "
"drivers need this for correct operation - Shapefile is one of them (other "
"drivers will ignore this parameter). Specifying the correct encoding is "
"important if you are using international (non US-ASCII) characters."
msgstr "De derde (verplichte) parameter specificeert de codering voor de uit te voeren tekst. Slechts enkele stuurprogramma's hebben dit voor een juiste verwerking nodig - Shapefile is er daar één van (andere stuurprogramma's zullen deze parameter negeren). Specificeren van de juiste codering is alleen belangrijk als u internationale tekens (niet US-ASCII) gebruikt."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:613
msgid ""
"You can also convert fields to make them compatible with different formats "
"by using the  :class:`FieldValueConverter "
"<qgis.core.QgsVectorFileWriter.FieldValueConverter>`. For example, to "
"convert array variable types (e.g. in Postgres) to a text type, you can do "
"the following:"
msgstr "U kunt ook velden converteren om ze uitwisselbaar te maken met verschillende indelingen door de klasse :class:`FieldValueConverter <qgis.core.QgsVectorFileWriter.FieldValueConverter>` te gebruiken. Bijvoorbeeld om typen arryvariabelen (bijv. in Postgres) te converteren naar een type tekst, kunt u het volgende doen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:650
msgid ""
"A destination CRS may also be specified --- if a valid instance of "
":class:`QgsCoordinateReferenceSystem "
"<qgis.core.QgsCoordinateReferenceSystem>` is passed as the fourth parameter,"
" the layer is transformed to that CRS."
msgstr "Een doel-CRS mag ook worden gespecificeerd --- als een geldige instance van :class:`QgsCoordinateReferenceSystem <qgis.core.QgsCoordinateReferenceSystem>` wordt doorgegeven als de vierde parameter, wordt de laag naar dat CRS getransformeerd."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:654
msgid ""
"For valid driver names please call the :meth:`supportedFiltersAndFormats "
"<qgis.core.QgsVectorFileWriter.supportedFiltersAndFormats>` method or "
"consult the `supported formats by OGR`_ --- you should pass the value in the"
" \"Code\" column as the driver name."
msgstr "Roep voor geldige namen van stuurprogramma's de methode :meth:`supportedFiltersAndFormats <qgis.core.QgsVectorFileWriter.supportedFiltersAndFormats>` aan of raadpleeg de `door OGR ondersteunde indelingen`_ --- u zou de waarde in de kolom \"Code\" moeten doorgeven als de naam van het stuurprogramma."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:659
msgid ""
"Optionally you can set whether to export only selected features, pass "
"further driver-specific options for creation or tell the writer not to "
"create attributes... There are a number of other (optional) parameters; see "
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` "
"documentation for details."
msgstr "Optioneel kunt u instellen of of u alleen geselecteerde objecten wilt exporteren, meer driver-specifieke opties voor maken wilt doorgeven of de schrijven wilt vertellen om geen attributen aan te maken… Er zijn een aantal andere (optionele) parameters; bekijk de documentatie voor :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` voor details."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:666
msgid "Directly from features"
msgstr "Direct uit objecten"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:705
msgid "From an instance of :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`"
msgstr "Vanuit een instance van :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:707
msgid ""
"Among all the data providers supported by the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class, let's focus on the memory-based layers. "
"Memory provider is intended to be used mainly by plugin or 3rd party app "
"developers. It does not store data on disk, allowing developers to use it as"
" a fast backend for some temporary layers."
msgstr "Laten we, naast alle gegevensproviders die worden ondersteund door de klasse :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`, ons focussen op de op geheugen gebaseerde lagen. Memory-provider is bedoeld om hoofdzakelijk te worden gebruikt door plug-ins of ontwikkelaars voor 3e partijen. Het slaat geen gegevens op de schijf op, wat ontwikkelaars in staat stelt het te gebruiken als snel backend voor enkele tijdelijke lagen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:713
msgid "The provider supports string, int and double fields."
msgstr "De provider ondersteunt velden string, int en double."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:715
msgid ""
"The memory provider also supports spatial indexing, which is enabled by "
"calling the provider's :meth:`createSpatialIndex() "
"<qgis.core.QgsVectorDataProvider.createSpatialIndex>` function. Once the "
"spatial index is created you will be able to iterate over features within "
"smaller regions faster (since it's not necessary to traverse all the "
"features, only those in specified rectangle)."
msgstr "De memory-provider ondersteunt ook ruimtelijke indexen, wat wordt ingeschakeld door de functie van de provider :meth:`createSpatialIndex() <qgis.core.QgsVectorDataProvider.createSpatialIndex>` aan te roepen. Als de ruimtelijke index eenmaal is gemaakt zult u in staat zijn objecten in kleinere regio's sneller te doorlopen (omdat het niet nodig is door alle objecten te gaan, alleen die in de gespecificeerde rechthoek)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:722
msgid ""
"A memory provider is created by passing ``\"memory\"`` as the provider "
"string to the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` "
"constructor."
msgstr "Een memory-provider wordt gemaakt door ``\"memory\"`` door te geven als de string voor de provider string aan de constructor :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:725
msgid ""
"The constructor also takes a URI defining the geometry type of the layer, "
"one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
"``\"MultiPoint\"``, ``\"MultiLineString\"``, ``\"MultiPolygon\"`` or "
"``\"None\"``."
msgstr "De constructor accepteert ook een URI die het type geometrie van de laag definieert, één van: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, ``\"MultiPoint\"``, ``\"MultiLineString\"``, ``\"MultiPolygon\"`` of ``\"None\"``."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:729
msgid ""
"The URI can also specify the coordinate reference system, fields, and "
"indexing of the memory provider in the URI. The syntax is:"
msgstr "De URI mag ook het coördinaten referentiesysteem specificeren, velden, en indexeren van de memory-provider in de URI. De syntaxis is:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:735
msgid "crs=definition"
msgstr "crs=definition"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:733
msgid ""
"Specifies the coordinate reference system, where definition may be any of "
"the forms accepted by :meth:`QgsCoordinateReferenceSystem.createFromString "
"<qgis.core.QgsCoordinateReferenceSystem.createFromString>`"
msgstr "Specificeert het coördinaten referentiesysteem, waar definition een van de vormen kan zijn die worden geaccepteerd door :meth:`QgsCoordinateReferenceSystem.createFromString <qgis.core.QgsCoordinateReferenceSystem.createFromString>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:738
msgid "index=yes"
msgstr "index=yes"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:738
msgid "Specifies that the provider will use a spatial index"
msgstr "Specificeert dat de provider een ruimtelijke index zal gebruiken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:743
msgid "field=name:type(length,precision)"
msgstr "field=name:type(length,precision)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:741
msgid ""
"Specifies an attribute of the layer.  The attribute has a name, and "
"optionally a type (integer, double, or string), length, and precision. There"
" may be multiple field definitions."
msgstr "Specificeert een attribuut van de laag. Het attribuut heeft een naam en, optioneel, een type (integer, double of string), lengte en precisie. Er kunnen meerdere definities voor velden zijn."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:745
msgid "The following example of a URI incorporates all these options"
msgstr "Het volgende voorbeeld van een URI bevat al deze opties"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:751
msgid ""
"The following example code illustrates creating and populating a memory "
"provider"
msgstr "De volgende voorbeeldcode illustreert het maken en vullen van een memory-provider"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:777
msgid "Finally, let's check whether everything went well"
msgstr "Laten we tenslotte controleren of alles goed ging"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:795
msgid "Appearance (Symbology) of Vector Layers"
msgstr "Uiterlijk (symbologie) van vectorlagen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:797
msgid ""
"When a vector layer is being rendered, the appearance of the data is given "
"by **renderer** and **symbols** associated with the layer.  Symbols are "
"classes which take care of drawing of visual representation of features, "
"while renderers determine what symbol will be used for a particular feature."
msgstr "Wanneer een vectorlaag wordt gerenderd wordt het uiterlijk van de gegevens verschaft door de **renderer** en **symbolen** geassocieerd met de laag.  Symbolen zijn klassen die zorg dragen voor het tekenen van visuele weergaven van objecten, terwijl renderers bepalen welk symbool zal worden gebruikt voor een bepaald object."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:802
msgid "The renderer for a given layer can be obtained as shown below:"
msgstr "De renderer voor een bepaalde laag kan worden verkregen zoals hieronder is weergegeven:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:808
msgid "And with that reference, let us explore it a bit"
msgstr "En met die verwijzing, laten we het een beetje verkennen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:814
msgid ""
"There are several known renderer types available in the QGIS core library:"
msgstr "Er zijn verschillende bekende typen renderer beschikbaar in de bron-bibliotheek van QGIS:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Type"
msgstr "Type"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Class"
msgstr "Klasse"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Description"
msgstr "Omschrijving"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid "singleSymbol"
msgstr "singleSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid ":class:`QgsSingleSymbolRenderer <qgis.core.QgsSingleSymbolRenderer>`"
msgstr ":class:`QgsSingleSymbolRenderer <qgis.core.QgsSingleSymbolRenderer>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid "Renders all features with the same symbol"
msgstr "Rendert alle objecten met hetzelfde symbool"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid "categorizedSymbol"
msgstr "categorizedSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid ""
":class:`QgsCategorizedSymbolRenderer "
"<qgis.core.QgsCategorizedSymbolRenderer>`"
msgstr ":class:`QgsCategorizedSymbolRenderer <qgis.core.QgsCategorizedSymbolRenderer>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid "Renders features using a different symbol for each category"
msgstr "Rendert objecten door een ander symbool voor elke categorie te gebruiken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid "graduatedSymbol"
msgstr "graduatedSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid ""
":class:`QgsGraduatedSymbolRenderer  <qgis.core.QgsGraduatedSymbolRenderer>`"
msgstr ":class:`QgsGraduatedSymbolRenderer  <qgis.core.QgsGraduatedSymbolRenderer>`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid "Renders features using a different symbol for each range of values"
msgstr "Rendert objecten door een ander symbool voor elke bereik van waarden te gebruiken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:826
msgid ""
"There might be also some custom renderer types, so never make an assumption "
"there are just these types. You can query the application's "
":class:`QgsRendererRegistry <qgis.core.QgsRendererRegistry>` to find out "
"currently available renderers:"
msgstr "Er kunnen ook enkele aangepaste typen renderer zijn, dus doe nooit de aanname dat alleen deze typen beschikbaar zijn. U kunt het :class:`QgsRendererRegistry <qgis.core.QgsRendererRegistry>` van de toepassing bevragen om de huidige beschikbare renderers te achterhalen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:845
msgid ""
"It is possible to obtain a dump of a renderer contents in text form --- can "
"be useful for debugging"
msgstr "Het is mogelijk om een dump te verkrijgen van de inhoud van een renderer in de vorm van tekst --- kan handig zijn bij debuggen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:855
msgid "Single Symbol Renderer"
msgstr "Renderer Enkel symbool "

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:857
msgid ""
"You can get the symbol used for rendering by calling :meth:`symbol() "
"<qgis.core.QgsSingleSymbolRenderer.symbol>` method and change it with "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` method "
"(note for C++ devs: the renderer takes ownership of the symbol.)"
msgstr "U kunt het voor de rendering gebruikte symbool verkrijgen door de methode :meth:`symbol() <qgis.core.QgsSingleSymbolRenderer.symbol>` aan te roepen en die te wijzigen met de methode :meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` (opmerking voor ontwikkelaars in C++: de renderer wordt eigenaar van het symbool.)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:861
msgid ""
"You can change the symbol used by a particular vector layer by calling "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` passing an"
" instance of the appropriate symbol instance. Symbols for *point*, *line* "
"and *polygon* layers can be created by calling the :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` function of the corresponding "
"classes :class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>`, "
":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` and :class:`QgsFillSymbol "
"<qgis.core.QgsFillSymbol>`."
msgstr "U kunt het symbool dat wordt gebruikt door een bepaalde vectorlaag wijzigen door :meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` aan te roepen die een instance doorgeeft van de toepasselijke symbool instance. Symbolen voor lagen *punt*, *lijn* en *polygoon* kunnen worden gemaakt door het aanroepen van de functie :meth:`createSimple() <qgis.core.QgsMarkerSymbol.createSimple>` van de overeenkomende klassen :class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>`, :class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` en :class:`QgsFillSymbol <qgis.core.QgsFillSymbol>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:868
msgid ""
"The dictionary passed to :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` sets the style properties of the "
"symbol."
msgstr "Het aan :meth:`createSimple() <qgis.core.QgsMarkerSymbol.createSimple>` doorgegeven woordenboek stelt de eigenschappen voor de stijl van het symbool in."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:871
msgid ""
"For example you can replace the symbol used by a particular **point** layer "
"by calling :meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>`"
" passing an instance of a :class:`QgsMarkerSymbol "
"<qgis.core.QgsMarkerSymbol>`, as in the following code example:"
msgstr "U kunt bijvoorbeeld het gebruikte symbool voor een bepaalde **punt**-laag wijzigen door :meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` aan te roepen die een instance doorgeeft van een :class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol> zoals in het volgende voorbeeld van code:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:882
msgid ""
"``name`` indicates the shape of the marker, and can be any of the following:"
msgstr "``name`` geeft de vorm van de markering aan, en kan één van de volgende zijn:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:884
msgid "``circle``"
msgstr "``circle``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:885
msgid "``square``"
msgstr "``square``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:886
msgid "``cross``"
msgstr "``cross``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:887
msgid "``rectangle``"
msgstr "``rectangle``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:888
msgid "``diamond``"
msgstr "``diamond``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:889
msgid "``pentagon``"
msgstr "``pentagon``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:890
msgid "``triangle``"
msgstr "``triangle``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:891
msgid "``equilateral_triangle``"
msgstr "``equilateral_triangle``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:892
msgid "``star``"
msgstr "``star``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:893
msgid "``regular_star``"
msgstr "``regular_star``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:894
msgid "``arrow``"
msgstr "``arrow``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:895
msgid "``filled_arrowhead``"
msgstr "``filled_arrowhead``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:896
msgid "``x``"
msgstr "``x``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:899
msgid ""
"To get the full list of properties for the first symbol layer of a symbol "
"instance you can follow the example code:"
msgstr "U kunt de voorbeeldcode volgen om een volledige lijst met eigenschappen te verkrijgen van de eerste symboollaag van een instance symbool :"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:925
msgid "This can be useful if you want to alter some properties:"
msgstr "Dit kan nuttig zijn als u enkele eigenschappen wilt wijzigen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:944
msgid "Categorized Symbol Renderer"
msgstr "Renderer symbool Categoriën"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:946
msgid ""
"When using a categorized renderer, you can query and set the attribute that "
"is used for classification: use the :meth:`classAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.classAttribute>` and "
":meth:`setClassAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.setClassAttribute>` methods."
msgstr "Bij het gebruiken van een renderer Categorieën kunt u het attribuut dat is gebruikt voor de classificatie bevragen en instellen: gebruik de methoden :meth:`classAttribute() <qgis.core.QgsCategorizedSymbolRenderer.classAttribute>` en :meth:`setClassAttribute() <qgis.core.QgsCategorizedSymbolRenderer.setClassAttribute>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:949
msgid "To get a list of categories"
msgstr "Een lijst categorieën verkrijgen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:956
msgid ""
"Where :meth:`value() <qgis.core.QgsRendererCategory.value>` is the value "
"used for discrimination between categories, :meth:`label() "
"<qgis.core.QgsRendererCategory.label>` is a text used for category "
"description and :meth:`symbol() <qgis.core.QgsRendererCategory.symbol>` "
"method returns the assigned symbol."
msgstr "Waar :meth:`value() <qgis.core.QgsRendererCategory.value>` de waarde is die wordt gebruikt voor het onderscheiden van de categorieën, :meth:`label() <qgis.core.QgsRendererCategory.label>` is een tekst die gebruikt wordt voor de omschrijving van de categorie en de methode :meth:`symbol() <qgis.core.QgsRendererCategory.symbol>` geeft het toegewezen symbool terug."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:960
msgid ""
"The renderer usually stores also original symbol and color ramp which were "
"used for the classification: :meth:`sourceColorRamp() "
"<qgis.core.QgsCategorizedSymbolRenderer.sourceColorRamp>` and "
":meth:`sourceSymbol() <qgis.core.QgsCategorizedSymbolRenderer.sourceSymbol>`"
" methods."
msgstr "De renderer slaat gewoonlijk ook het originele symbool en de kleurenbalk op die voor de classificatie werden gebruikt: methoden :meth:`sourceColorRamp() <qgis.core.QgsCategorizedSymbolRenderer.sourceColorRamp>` en :meth:`sourceSymbol() <qgis.core.QgsCategorizedSymbolRenderer.sourceSymbol>`."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:966
msgid "Graduated Symbol Renderer"
msgstr "Renderer symbool Gradueel"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:968
msgid ""
"This renderer is very similar to the categorized symbol renderer described "
"above, but instead of one attribute value per class it works with ranges of "
"values and thus can be used only with numerical attributes."
msgstr "Deze renderer lijkt erg veel op de renderer voor het symbool van de categorieën, hierboven beschreven, maar in plaats van één attribuutwaarde per klasse, werkt het met bereiken van waarden en kan dus alleen gebruikt worden met numerieke attributen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:972
msgid "To find out more about ranges used in the renderer"
msgstr "Meer te weten komen over gebruikte bereiken in de renderer"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:984
msgid ""
"you can again use the :meth:`classAttribute "
"<qgis.core.QgsGraduatedSymbolRenderer.classAttribute>` (to find the "
"classification attribute name), :meth:`sourceSymbol "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceSymbol>` and "
":meth:`sourceColorRamp "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceColorRamp>` methods. "
"Additionally there is the :meth:`mode "
"<qgis.core.QgsGraduatedSymbolRenderer.mode>` method which determines how the"
" ranges were created: using equal intervals, quantiles or some other method."
msgstr "U kunt opnieuw de methoden :meth:`classAttribute <qgis.core.QgsGraduatedSymbolRenderer.classAttribute>` (om de naam van het attribuut voor classificatie te zoeken), :meth:`sourceSymbol <qgis.core.QgsGraduatedSymbolRenderer.sourceSymbol>` en :meth:`sourceColorRamp <qgis.core.QgsGraduatedSymbolRenderer.sourceColorRamp>` gebruiken. Aanvullend is er de methode :meth:`mode <qgis.core.QgsGraduatedSymbolRenderer.mode>` die bepaalt hoe de bereiken werden gemaakt: met behulp van gelijke intervallen, kwantielen of een andere methode."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:993
msgid ""
"If you wish to create your own graduated symbol renderer you can do so as "
"illustrated in the example snippet below (which creates a simple two class "
"arrangement)"
msgstr "Als u uw eigen renderer voor symbolen Gradueel wilt maken, kunt u dat doen zoals is geïllustreerd in het voorbeeldsnippet hieronder (wat een eenvoudige schikking in twee klassen maakt)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1037
msgid "Working with Symbols"
msgstr "Werken met symbolen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1039
msgid ""
"For representation of symbols, there is :class:`QgsSymbol "
"<qgis.core.QgsSymbol>` base class with three derived classes:"
msgstr "Voor het weergeven van symbolen is er de basisklasse :class:`QgsSymbol <qgis.core.QgsSymbol>` met drie afgeleide klassen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1042
msgid ""
":class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>` --- for point features"
msgstr ":class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>` --- voor objecten punt"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1043
msgid ":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` --- for line features"
msgstr ":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` --- voor objecten lijn"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1044
msgid ""
":class:`QgsFillSymbol <qgis.core.QgsFillSymbol>` --- for polygon features"
msgstr ":class:`QgsFillSymbol <qgis.core.QgsFillSymbol>` --- voor objecten polygoon"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1046
msgid ""
"**Every symbol consists of one or more symbol layers** (classes derived from"
" :class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>`). The symbol layers do "
"the actual rendering, the symbol class itself serves only as a container for"
" the symbol layers."
msgstr "**Elk symbool bestaat uit één of meer symboollagen** (klassen afgeleid van :class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>`). De symboollagen doen de actuele rendering, de symboolklasse zelf dient alleen als een container voor de symboollagen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1050
msgid ""
"Having an instance of a symbol (e.g. from a renderer), it is possible to "
"explore it: the :meth:`type <qgis.core.QgsSymbol.type>` method says whether "
"it is a marker, line or fill symbol. There is a :meth:`dump "
"<qgis.core.QgsSymbol.dump>` method which returns a brief description of the "
"symbol. To get a list of symbol layers:"
msgstr "Met een instance van een symbool (bijv. van een renderer), is het mogelijk om het te verkennen: de methode :meth:`type <qgis.core.QgsSymbol.type>` zegt of het een symbool markering, lijn of vulling is. Er is de methode :meth:`dump <qgis.core.QgsSymbol.dump>` wat een korte omschrijving van het symbool teruggeeft. Een lijst van symboollagen verkrijgen:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1062
msgid ""
"To find out symbol's color use :meth:`color <qgis.core.QgsSymbol.color>` "
"method and :meth:`setColor <qgis.core.QgsSymbol.setColor>` to change its "
"color. With marker symbols additionally you can query for the symbol size "
"and rotation with the :meth:`size <qgis.core.QgsMarkerSymbol.size>` and "
":meth:`angle <qgis.core.QgsMarkerSymbol.angle>` methods. For line symbols "
"the :meth:`width <qgis.core.QgsLineSymbol.width>` method returns the line "
"width."
msgstr "Gebruik de methode :meth:`color <qgis.core.QgsSymbol.color>` om de kleur van het symbool vast te stellen en :meth:`setColor <qgis.core.QgsSymbol.setColor> om die kleur te wijzigen. Met aanvullende markeringssymbolen kunt u vragen naar de grootte en rotatie van het symbool met de methoden  :meth:`size <qgis.core.QgsMarkerSymbol.size>` en :meth:`angle <qgis.core.QgsMarkerSymbol.angle>`, voor lijnsymbolen geeft de methode :meth:`width <qgis.core.QgsLineSymbol.width>` de dikte van de lijn terug."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1067
msgid "Size and width are in millimeters by default, angles are in degrees."
msgstr "Grootte en breedte zijn standaard in millimeters, hoeken zijn in graden."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1072
msgid "Working with Symbol Layers"
msgstr "Werken met symboollagen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1074
msgid ""
"As said before, symbol layers (subclasses of :class:`QgsSymbolLayer "
"<qgis.core.QgsSymbolLayer>`) determine the appearance of the features.  "
"There are several basic symbol layer classes for general use. It is possible"
" to implement new symbol layer types and thus arbitrarily customize how "
"features will be rendered. The :meth:`layerType() "
"<qgis.core.QgsSymbolLayer.layerType>` method uniquely identifies the symbol "
"layer class --- the basic and default ones are ``SimpleMarker``, "
"``SimpleLine`` and ``SimpleFill`` symbol layers types."
msgstr "Zoals eerder gezegd bepalen symboollagen (subklassen van :class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>`) het uiterlijk van de objecten. Er zijn verscheidene basisklassen voor symboollagen voor algemeen gebruik. Het is mogelijk om nieuwe typen symboollagen te implementeren en dus willekeurig aan te passen hoe objecten zullen worden gerenderd. De methode :meth:`layerType() <qgis.core.QgsSymbolLayer.layerType>` identificeert uniek de klasse van de symboollaag --- de basis en standaard zijn de typen symboollagen ``SimpleMarker``, ``SimpleLine`` en ``SimpleFill``."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1081
msgid ""
"You can get a complete list of the types of symbol layers you can create for"
" a given symbol layer class with the following code:"
msgstr "U kunt een volledige lijst van de typen symboollagen, die u  voor een bepaalde klasse van een  symboollaag kunt maken, verkrijgen met de volgende code:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1092
msgid "Output:"
msgstr "Uitvoer:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1104
msgid ""
"The :class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` class"
" manages a database of all available symbol layer types."
msgstr "Klasse :class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` beheert een database van alle beschikbare typen symboollagen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1107
msgid ""
"To access symbol layer data, use its :meth:`properties() "
"<qgis.core.QgsSymbolLayer.properties>` method that returns a key-value "
"dictionary of properties which determine the appearance. Each symbol layer "
"type has a specific set of properties that it uses. Additionally, there are "
"the generic methods :meth:`color <qgis.core.QgsSymbol.color>`, :meth:`size "
"<qgis.core.QgsMarkerSymbol.size>`, :meth:`angle "
"<qgis.core.QgsMarkerSymbol.angle>` and :meth:`width "
"<qgis.core.QgsLineSymbol.width>`, with their setter counterparts. Of course "
"size and angle are available only for marker symbol layers and width for "
"line symbol layers."
msgstr "Gebruik zijn methode :meth:`properties() <qgis.core.QgsSymbolLayer.properties>` om toegang te verkrijgen tot de gegevens van de symboollaag, die een woordenboek met paren van sleutels-waarden teruggeeft van eigenschappen die het uiterlijk bepalen. Elke type symboollaag heeft een specifieke set eigenschappen die het gebruikt. Aanvullend zijn er de generieke methoden :meth:`color <qgis.core.QgsSymbol.color>`, :meth:`size <qgis.core.QgsMarkerSymbol.size>`, :meth:`angle <qgis.core.QgsMarkerSymbol.angle>` en :meth:`width <qgis.core.QgsLineSymbol.width>` met hun tegenhangers om ze in te stellen. Natuurlijk zijn grootte en hoek alleen beschikbaar voor symboollagen voor markeringen en breedte voor lijn-symboollagen."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1119
msgid "Creating Custom Symbol Layer Types"
msgstr "Aangepaste typen voor symboollagen maken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1121
msgid ""
"Imagine you would like to customize the way how the data gets rendered. You "
"can create your own symbol layer class that will draw the features exactly "
"as you wish. Here is an example of a marker that draws red circles with "
"specified radius"
msgstr "Veronderstel dat u de manier waarop gegevens worden gerenderd wilt aanpassen. U kunt uw eigen klasse voor de symboollaag maken dat de objecten op exact de wijze die u wilt tekent. Hier is een voorbeeld van een markering die rode cirkels met een gespecificeerde straal tekent"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1161
msgid ""
"The :meth:`layerType <qgis.core.QgsSymbolLayer.layerType>` method determines"
" the name of the symbol layer; it has to be unique among all symbol layers. "
"The :meth:`properties <qgis.core.QgsSymbolLayer.properties>` method is used "
"for persistence of attributes. The :meth:`clone "
"<qgis.core.QgsSymbolLayer.clone>` method must return a copy of the symbol "
"layer with all attributes being exactly the same. Finally there are "
"rendering methods: :meth:`startRender "
"<qgis.core.QgsSymbolLayer.startRender>` is called before rendering the first"
" feature, :meth:`stopRender <qgis.core.QgsSymbolLayer.stopRender>` when the "
"rendering is done, and :meth:`renderPoint "
"<qgis.core.QgsMarkerSymbolLayer.renderPoint>` is called to do the rendering."
" The coordinates of the point(s) are already transformed to the output "
"coordinates."
msgstr "De methode :meth:`layerType <qgis.core.QgsSymbolLayer.layerType>` bepaalt de naam van de symboollaag, die moet uniek zijn voor alle symboollagen. De methode :meth:`properties <qgis.core.QgsSymbolLayer.properties>` wordt gebruikt voor het behouden van attributen. De methode :meth:`clone <qgis.core.QgsSymbolLayer.clone>` moet een kopie teruggeven van de symboollaag met exact dezelfde attributen. Tenslotte zijn er methoden voor renderen: :meth:`startRender <qgis.core.QgsSymbolLayer.startRender>` wordt aangeroepen vóór het renderen van het eerste object,  :meth:`stopRender <qgis.core.QgsSymbolLayer.stopRender>` als het renderen is voltooid en de methode :meth:`renderPoint <qgis.core.QgsMarkerSymbolLayer.renderPoint>` wordt aangeroepen om het renderen uit te voeren. De coördinaten van de punt(en) zijn al getransformeerd naar de coördinaten voor uitvoer."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1173
msgid ""
"For polylines and polygons the only difference would be in the rendering "
"method: you would use :meth:`renderPolyline "
"<qgis.core.QgsLineSymbolLayer.renderPolyline>` which receives a list of "
"lines, while :meth:`renderPolygon "
"<qgis.core.QgsFillSymbolLayer.renderPolygon>` receives a list of points on "
"the outer ring as the first parameter and a list of inner rings (or None) as"
" a second parameter."
msgstr "Voor polylijnen en polygonen zou het enige verschil liggen in de methode van renderen: u zou :meth:`renderPolyline <qgis.core.QgsLineSymbolLayer.renderPolyline>` gebruiken, welke een lijst met lijnen zou ontvangen, terwijl :meth:`renderPolygon <qgis.core.QgsFillSymbolLayer.renderPolygon>` een lijst van punten op de buitenste ring als de eerste parameter ontvangt en een lijst van binnenringen (of None) als een tweede parameter."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1181
msgid ""
"Usually it is convenient to add a GUI for setting attributes of the symbol "
"layer type to allow users to customize the appearance: in case of our "
"example above we can let user set circle radius. The following code "
"implements such widget"
msgstr "Gewoonlijk is het handig om een GUI toe te voegen voor het instellen van attributen voor het  type symboollaag om het voor gebruikers mogelijk te maken het uiterlijk aan te passen: in het geval van ons voorbeeld hierboven kunnen we de gebruiker de straal van de cirkel laten instellen. De volgende code implementeert een dergelijk widget"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1219
msgid ""
"This widget can be embedded into the symbol properties dialog. When the "
"symbol layer type is selected in symbol properties dialog, it creates an "
"instance of the symbol layer and an instance of the symbol layer widget. "
"Then it calls the :meth:`setSymbolLayer "
"<qgis.gui.QgsSymbolLayerWidget.setSymbolLayer>` method to assign the symbol "
"layer to the widget. In that method the widget should update the UI to "
"reflect the attributes of the symbol layer. The :meth:`symbolLayer "
"<qgis.gui.QgsSymbolLayerWidget.symbolLayer>` method is used to retrieve the "
"symbol layer again by the properties dialog to use it for the symbol."
msgstr "Deze widget kan worden ingebed in het dialoogvenster van de eigenschappen voor het symbool. Wanneer het type symboollaag wordt geselecteerd in het dialoogvenster van de eigenschappen voor het symbool, maakt het een instance van de symboollaag en een instance van de widget van de symboollaag. Dan roept het de methode :meth:`setSymbolLayer <qgis.gui.QgsSymbolLayerWidget.setSymbolLayer>` aan om de symboollaag toe te wijzen aan de widget. In die methode zou de widget de UI moeten bijwerken om de attributen van de symboollaag weer te geven. De methode :meth:`symbolLayer <qgis.gui.QgsSymbolLayerWidget.symbolLayer>` wordt gebruikt om de symboollaag opnieuw op te halen bij het dialoogvenster Eigenschappen om het voor het symbool te gebruiken."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1229
msgid ""
"On every change of attributes, the widget should emit the :any:`changed() "
"<qgis.gui.QgsSymbolLayerWidget.changed>` signal to let the properties dialog"
" update the symbol preview."
msgstr "Bij elke wijziging van attributen zou de widget een signaal :any:`changed() <qgis.gui.QgsSymbolLayerWidget.changed>` moeten uitzenden om het dialoogvenster Eigenschappen het voorbeeld van het symbool bij te laten werken."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1233
msgid ""
"Now we are missing only the final glue: to make QGIS aware of these new "
"classes. This is done by adding the symbol layer to registry. It is possible"
" to use the symbol layer also without adding it to the registry, but some "
"functionality will not work: e.g. loading of project files with the custom "
"symbol layers or inability to edit the layer's attributes in GUI."
msgstr "Nu missen we alleen nog de uiteindelijke lijm: om QGIS zich bewust te laten worden van deze nieuwe klassen. Dit wordt gedaan door de symboollaag toe te voegen aan het register. Het is mogelijk om de symboollaag ook te gebruiken zonder die toe te voegen aan het register, maar sommige functionaliteit zal niet werken: bijv. het laden van projectbestanden met de aangepaste symboollagen of de mogelijkheid om de attributen van de laag te bewerken in de GUI."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1239
msgid "We will have to create metadata for the symbol layer"
msgstr "We zullen metadata moeten maken voor de symboollaag"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1260
msgid ""
"You should pass layer type (the same as returned by the layer) and symbol "
"type (marker/line/fill) to the constructor of the parent class. The "
":meth:`createSymbolLayer() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` method takes "
"care of creating an instance of symbol layer with attributes specified in "
"the `props` dictionary. And there is the :meth:`createSymbolLayerWidget() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` method "
"which returns the settings widget for this symbol layer type."
msgstr "U zou het type laag (hetzelfde als welke wordt teruggegeven door de laag) en type symbool (markering/lijn/vulling) moeten doorgeven aan de constructor van de bovenliggende klasse. De methode :meth:`createSymbolLayer() <qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>`  zorgt voor het maken van een instance van de symboollaag met attributen die zijn gespecificeerd in het woordenboek `props`. En er is de methode :meth:`createSymbolLayerWidget() <qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` die de instellingen voor de widget teruggeeft voor dit type symboollaag."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1268
msgid ""
"The last step is to add this symbol layer to the registry --- and we are "
"done."
msgstr "De laatste stap is om deze symboollaag toe te voegen aan het register --- en we zijn klaar."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1274
msgid "Creating Custom Renderers"
msgstr "Aangepaste renderers maken"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1276
msgid ""
"It might be useful to create a new renderer implementation if you would like"
" to customize the rules how to select symbols for rendering of features. "
"Some use cases where you would want to do it: symbol is determined from a "
"combination of fields, size of symbols changes depending on current scale "
"etc."
msgstr "Het zou handig kunnen zijn om een nieuwe implementatie voor de renderer te maken als u de regels voor het selecteren van symbolen voor het renderen van objecten zou willen aanpassen. Sommige gebruiken gevallen waarin u dit zou willen doen: symbool wordt bepaald uit een combinatie van velden, grootte van symbolen wijzigt, afhankelijk van hun huidige schaal etc."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1281
msgid ""
"The following code shows a simple custom renderer that creates two marker "
"symbols and chooses randomly one of them for every feature"
msgstr "De volgende code geeft een eenvoudige aangepaste renderer weer die twee markeringssymbolen maakt en er, willekeurig, één kiest voor elk object"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1337
msgid ""
"The constructor of the parent :class:`QgsFeatureRenderer "
"<qgis.core.QgsFeatureRenderer>` class needs a renderer name (which has to be"
" unique among renderers). The :meth:`symbolForFeature "
"<qgis.core.QgsFeatureRenderer.symbolForFeature>` method is the one that "
"decides what symbol will be used for a particular feature. "
":meth:`startRender <qgis.core.QgsFeatureRenderer.startRender>` and "
":meth:`stopRender <qgis.core.QgsFeatureRenderer.stopRender>` take care of "
"initialization/finalization of symbol rendering. The :meth:`usedAttributes "
"<qgis.core.QgsFeatureRenderer.usedAttributes>` method can return a list of "
"field names that the renderer expects to be present. Finally, the "
":meth:`clone <qgis.core.QgsFeatureRenderer.clone>` method should return a "
"copy of the renderer."
msgstr "De constructor van de bovenliggende klasse :class:`QgsFeatureRenderer <qgis.core.QgsFeatureRenderer>` heeft de naam van de renderer nodig (die uniek moet zijn voor alle renderers). De methode :meth:`symbolForFeature <qgis.core.QgsFeatureRenderer.symbolForFeature>` is die welke bepaalt welk symbool zal worden gebruikt voor een bepaald object.  :meth:`startRender <qgis.core.QgsFeatureRenderer.startRender>` en :meth:`stopRender <qgis.core.QgsFeatureRenderer.stopRender>` zorgen voor initialisatie/finalisatie van het renderen van het symbool. De methode :meth:`usedAttributes <qgis.core.QgsFeatureRenderer.usedAttributes>` kan een lijst met veldnamen teruggeven waarvan de renderer verwacht dat die aanwezig is. Tenslotte zou de methode :meth:`clone <qgis.core.QgsFeatureRenderer.clone>` een kopie van de renderer moeten teruggeven."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1348
msgid ""
"Like with symbol layers, it is possible to attach a GUI for configuration of"
" the renderer. It has to be derived from :class:`QgsRendererWidget "
"<qgis.gui.QgsRendererWidget>`. The following sample code creates a button "
"that allows the user to set the first symbol"
msgstr "Net als met symboollagen is het mogelijk een GUI toe te voegen voor de configuratie van de renderer. Die moet worden afgeleid uit :class:`QgsRendererWidget  <qgis.gui.QgsRendererWidget>`. De volgende voorbeeldcode maakt een knop die de gebruiker in staat stelt het eerste symbool in te stellen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1382
msgid ""
"The constructor receives instances of the active layer "
"(:class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`), the global style "
"(:class:`QgsStyle <qgis.core.QgsStyle>`) and the current renderer. If there "
"is no renderer or the renderer has different type, it will be replaced with "
"our new renderer, otherwise we will use the current renderer (which has "
"already the type we need). The widget contents should be updated to show "
"current state of the renderer. When the renderer dialog is accepted, the "
"widget's :meth:`renderer <qgis.gui.QgsRendererWidget.renderer>` method is "
"called to get the current renderer --- it will be assigned to the layer."
msgstr "De constructor ontvangt instances van de actieve laag (:class:`QgsVectorLayer  <qgis.core.QgsVectorLayer>`), de globale opmaak (:class:`QgsStyle  <qgis.core.QgsStyle>`) en huidige renderer. Indien er geen renderer is of de renderer heeft een andere type, zal die worden vervangen door onze nieuwe renderer, anders zullen we de huidige renderer gebruiken (die al het type heeft dat we nodig hebben). De inhoud van de widget zou moeten worden bijgewerkt om de huidige staat van de renderer weer te geven. Wanneer het dialoogvenster van de renderer wordt geaccepteerd, wordt de methode voor de widget :meth:`renderer <qgis.gui.QgsRendererWidget.renderer>` aangeroepen om de huidige renderer te verkrijgen --- die zal worden toegewezen aan de laag."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1392
msgid ""
"The last missing bit is the renderer metadata and registration in registry, "
"otherwise loading of layers with the renderer will not work and user will "
"not be able to select it from the list of renderers. Let us finish our "
"RandomRenderer example"
msgstr "Het laatste ontbrekende gedeelte zijn de metadata voor de renderer en het registreren in het register, anders zal het laden van de lagen met de renderer niet werken en zal de gebruiker niet in staat zijn die te selecteren uit de lijst met renderers. Laten we ons voorbeeld RandomRenderer voltooien"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1412
msgid ""
"Similarly as with symbol layers, abstract metadata constructor awaits "
"renderer name, name visible for users and optionally name of renderer's "
"icon. The :meth:`createRenderer "
"<qgis.core.QgsRendererAbstractMetadata.createRenderer>` method passes a "
":class:`QDomElement` instance that can be used to restore the renderer's "
"state from the DOM tree. The :meth:`createRendererWidget "
"<qgis.core.QgsRendererAbstractMetadata.createRendererWidget>` method creates"
" the configuration widget. It does not have to be present or can return "
"``None`` if the renderer does not come with GUI."
msgstr "Soortgelijk als met de symboollagen, verwacht de constructor voor abstracte metadata de naam van de renderer, de zichtbare naam voor de gebruikers en optioneel de naam van het pictogram voor de renderer. De methode :meth:`createRenderer <qgis.core.QgsRendererAbstractMetadata.createRenderer>` geeft de instance :class:`QDomElement` door die kan worden gebruikt om de status van de renderer opnieuw op te slaan in de boom van de DOM. De methode :meth:`createRendererWidget <qgis.core.QgsRendererAbstractMetadata.createRendererWidget>` maakt het widget voor de configuratie. Die hoeft niet aanwezig te zijn of mag ``None`` teruggeven als de renderer geen GUI heeft."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1421
msgid ""
"To associate an icon with the renderer you can assign it in the "
":class:`QgsRendererAbstractMetadata <qgis.core.QgsRendererAbstractMetadata>`"
" constructor as a third (optional) argument --- the base class constructor "
"in the RandomRendererMetadata :func:`__init__` function becomes"
msgstr "U kunt, om een pictogram te associëren met de renderer, die toewijzen in de constructor :class:`QgsRendererAbstractMetadata <qgis.core.QgsRendererAbstractMetadata>` als een derde (optioneel) argument --- de basis klassse-constructor in de functie :func:`__init__` van de RandomRendererMetadata wordt"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1434
msgid ""
"The icon can also be associated at any later time using the :meth:`setIcon "
"<qgis.core.QgsRendererAbstractMetadata.setIcon>` method of the metadata "
"class. The icon can be loaded from a file (as shown above) or can be loaded "
"from a `Qt resource <https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 "
"includes .qrc compiler for Python)."
msgstr "Het pictogram kan ook op een later tijdstip worden geassocieerd met de methode :meth:`setIcon <qgis.core.QgsRendererAbstractMetadata.setIcon>` van de klasse van de metadata. Het pictogram kan worden geladen vanuit een bestand (zoals hierboven weergegeven) of kan worden geladen vanuit een `Qt resource <https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 bevat .qrc compiler voor Python)."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1442
msgid "Further Topics"
msgstr "Meer onderwerpen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1445
msgid "**TODO:**"
msgstr "**TODO:**"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1447
msgid "creating/modifying symbols"
msgstr "symbolen maken/aanpassen"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1448
msgid "working with style (:class:`QgsStyle <qgis.core.QgsStyle>`)"
msgstr "werken met stijl (:class:`QgsStyle <qgis.core.QgsStyle>`)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1449
msgid ""
"working with color ramps (:class:`QgsColorRamp <qgis.core.QgsColorRamp>`)"
msgstr "werken met kleurverlopen  (:class:`QgsColorRamp <qgis.core.QgsColorRamp>`)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1450
msgid "exploring symbol layer and renderer registries"
msgstr "symboollaag en registraties van renderer verkennen"

#~ msgid ""
#~ "You can retrieve information about the fields associated with a vector layer"
#~ " by calling :func:`pendingFields` on a :class:`QgsVectorLayer` instance::"
#~ msgstr ""

#~ msgid ""
#~ "Starting from QGIS 2.12 there is also a :func:`fields()` in "
#~ ":class:`QgsVectorLayer` which is an alias to :func:`pendingFields`."
#~ msgstr ""

#~ msgid ""
#~ "In QGIS desktop, features can be selected in different ways, the user can "
#~ "click on a feature, draw a rectangle on the map canvas or use an expression "
#~ "filter. Selected features are normally highlighted in a different color "
#~ "(default is yellow) to draw user's attention on the selection. Sometimes can"
#~ " be useful to programmatically select features or to change the default "
#~ "color."
#~ msgstr ""

#~ msgid ""
#~ "To change the selection color you can use :func:`setSelectionColor()` method"
#~ " of :class:`QgsMapCanvas` as shown in the following example::"
#~ msgstr ""

#~ msgid ""
#~ "To add add features to the selected features list for a given layer, you can"
#~ " call :func:`setSelectedFeatures()` passing to it the list of features IDs::"
#~ msgstr ""

#~ msgid "To clear the selection, just pass an empty list::"
#~ msgstr ""

#~ msgid ""
#~ "Iterating over the features in a vector layer is one of the most common "
#~ "tasks. Below is an example of the simple basic code to perform this task and"
#~ " showing some information about each feature. the ``layer`` variable is "
#~ "assumed to have a :class:`QgsVectorLayer` object"
#~ msgstr ""

#~ msgid "Attributes can be referred to by their name."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, attributes can be referred to by index. This is will be a bit"
#~ " faster than using the name. For example, to get the first attribute:"
#~ msgstr ""

#~ msgid ""
#~ "if you only need selected features, you can use the :func:`selectedFeatures`"
#~ " method from vector layer:"
#~ msgstr ""

#~ msgid "Another option is the Processing :func:`features` method:"
#~ msgstr ""

#~ msgid ""
#~ "By default, this will iterate over all the features in the layer, in case "
#~ "there is no selection, or over the selected features otherwise. Note that "
#~ "this behavior can be changed in the Processing options to ignore selections."
#~ msgstr ""

#~ msgid ""
#~ "If you want to iterate over a given subset of features in a layer, such as "
#~ "those within a given area, you have to add a :obj:`QgsFeatureRequest` object"
#~ " to the :func:`getFeatures()` call. Here's an example"
#~ msgstr ""

#~ msgid ""
#~ "With :func:`setLimit()` you can limit the number of requested features. "
#~ "Here's an example"
#~ msgstr ""

#~ msgid ""
#~ "If you need an attribute-based filter instead (or in addition) of a spatial "
#~ "one like shown in the examples above, you can build an :obj:`QgsExpression` "
#~ "object and pass it to the :obj:`QgsFeatureRequest` constructor. Here's an "
#~ "example"
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`expressions` for the details about the syntax supported by "
#~ ":class:`QgsExpression`."
#~ msgstr ""

#~ msgid "**Speed features request**"
#~ msgstr ""

#~ msgid ""
#~ "If you only need a subset of the attributes or you don't need the geometry "
#~ "information, you can significantly increase the **speed** of the features "
#~ "request by using ``QgsFeatureRequest.NoGeometry`` flag or specifying a "
#~ "subset of attributes (possibly empty) like shown in the example above."
#~ msgstr ""

#~ msgid ""
#~ "Most vector data providers support editing of layer data. Sometimes they "
#~ "support just a subset of possible editing actions. Use the "
#~ ":func:`capabilities` function to find out what set of functionality is "
#~ "supported"
#~ msgstr ""

#~ msgid ""
#~ "For a list of all available capabilities, please refer to the `API "
#~ "Documentation of QgsVectorDataProvider "
#~ "<http://qgis.org/api/classQgsVectorDataProvider.html>`_"
#~ msgstr ""

#~ msgid ""
#~ "To print layer's capabilities textual description in a comma separated list "
#~ "you can use :func:`capabilitiesString` as in the following example:"
#~ msgstr ""

#~ msgid ""
#~ "Create some :class:`QgsFeature` instances and pass a list of them to "
#~ "provider's :func:`addFeatures` method. It will return two values: result "
#~ "(true/false) and list of added features (their ID is set by the data store)."
#~ msgstr ""

#~ msgid ""
#~ "To set up the attributes you can either initialize the feature passing a "
#~ ":class:`QgsFields` instance or call :func:`initAttributes` passing the "
#~ "number of fields you want to be added."
#~ msgstr ""

#~ msgid "To delete some features, just provide a list of their feature IDs"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to either change feature's geometry or to change some "
#~ "attributes. The following example first changes values of attributes with "
#~ "index 0 and 1, then it changes the feature's geometry"
#~ msgstr ""

#~ msgid ""
#~ "If you only need to change geometries, you might consider using the "
#~ ":class:`QgsVectorLayerEditUtils` which provides some of useful methods to "
#~ "edit geometries (translate, insert or move vertex etc.)."
#~ msgstr ""

#~ msgid ""
#~ "Using ``with edit(layer):`` the changes will be commited automatically "
#~ "calling :func:`commitChanges()` at the end. If any exception occurs, it will"
#~ " :func:`rollBack()` all the changes. See :ref:`editing-buffer`."
#~ msgstr ""

#~ msgid ""
#~ "When editing vectors within QGIS application, you have to first start "
#~ "editing mode for a particular layer, then do some modifications and finally "
#~ "commit (or rollback) the changes. All the changes you do are not written "
#~ "until you commit them --- they stay in layer's in-memory editing buffer. It "
#~ "is possible to use this functionality also programmatically --- it is just "
#~ "another method for vector layer editing that complements the direct usage of"
#~ " data providers. Use this option when providing some GUI tools for vector "
#~ "layer editing, since this will allow user to decide whether to "
#~ "commit/rollback and allows the usage of undo/redo. When committing changes, "
#~ "all changes from the editing buffer are saved to data provider."
#~ msgstr ""

#~ msgid ""
#~ "To find out whether a layer is in editing mode, use :func:`isEditable` --- "
#~ "the editing functions work only when the editing mode is turned on. Usage of"
#~ " editing functions"
#~ msgstr ""

#~ msgid ""
#~ "In order to make undo/redo work properly, the above mentioned calls have to "
#~ "be wrapped into undo commands. (If you do not care about undo/redo and want "
#~ "to have the changes stored immediately, then you will have easier work by "
#~ ":ref:`editing with data provider <editing>`.) How to use the undo "
#~ "functionality"
#~ msgstr ""

#~ msgid ""
#~ "The :func:`beginEditCommand` will create an internal \"active\" command and "
#~ "will record subsequent changes in vector layer. With the call to "
#~ ":func:`endEditCommand` the command is pushed onto the undo stack and the "
#~ "user will be able to undo/redo it from GUI. In case something went wrong "
#~ "while doing the changes, the :func:`destroyEditCommand` method will remove "
#~ "the command and rollback all changes done while this command was active."
#~ msgstr ""

#~ msgid ""
#~ "To start editing mode, there is :func:`startEditing()` method, to stop "
#~ "editing there are :func:`commitChanges()` and :func:`rollBack()` --- however"
#~ " normally you should not need these methods and leave this functionality to "
#~ "be triggered by the user."
#~ msgstr ""

#~ msgid ""
#~ "This will automatically call :func:`commitChanges()` in the end. If any "
#~ "exception occurs, it will :func:`rollBack()` all the changes. In case a "
#~ "problem is encountered within :func:`commitChanges()` (when the method "
#~ "returns False) a :class:`QgsEditError` exception will be raised."
#~ msgstr ""

#~ msgid "create spatial index --- the following code creates an empty index"
#~ msgstr ""

#~ msgid ""
#~ "add features to index --- index takes :class:`QgsFeature` object and adds it"
#~ " to the internal data structure. You can create the object manually or use "
#~ "one from previous call to provider's :func:`nextFeature()`"
#~ msgstr ""

#~ msgid "Writing Vector Layers"
#~ msgstr ""

#~ msgid ""
#~ "You can write vector layer files using :class:`QgsVectorFileWriter` class. "
#~ "It supports any other kind of vector file that OGR supports (shapefiles, "
#~ "GeoJSON, KML and others)."
#~ msgstr ""

#~ msgid "There are two possibilities how to export a vector layer:"
#~ msgstr ""

#~ msgid "from an instance of :class:`QgsVectorLayer`"
#~ msgstr ""

#~ msgid ""
#~ "The third parameter specifies output text encoding. Only some drivers need "
#~ "this for correct operation - shapefiles are one of those --- however in case"
#~ " you are not using international characters you do not have to care much "
#~ "about the encoding. The fourth parameter that we left as ``None`` may "
#~ "specify destination CRS --- if a valid instance of "
#~ ":class:`QgsCoordinateReferenceSystem` is passed, the layer is transformed to"
#~ " that CRS."
#~ msgstr ""

#~ msgid "directly from features"
#~ msgstr ""

#~ msgid "Memory Provider"
#~ msgstr ""

#~ msgid ""
#~ "Memory provider is intended to be used mainly by plugin or 3rd party app "
#~ "developers. It does not store data on disk, allowing developers to use it as"
#~ " a fast backend for some temporary layers."
#~ msgstr ""

#~ msgid ""
#~ "The memory provider also supports spatial indexing, which is enabled by "
#~ "calling the provider's :func:`createSpatialIndex` function. Once the spatial"
#~ " index is created you will be able to iterate over features within smaller "
#~ "regions faster (since it's not necessary to traverse all the features, only "
#~ "those in specified rectangle)."
#~ msgstr ""

#~ msgid ""
#~ "A memory provider is created by passing ``\"memory\"`` as the provider "
#~ "string to the :class:`QgsVectorLayer` constructor."
#~ msgstr ""

#~ msgid ""
#~ "Specifies the coordinate reference system, where definition may be any of "
#~ "the forms accepted by :func:`QgsCoordinateReferenceSystem.createFromString`"
#~ msgstr ""

#~ msgid "The renderer for a given layer can obtained as shown below:"
#~ msgstr ""

#~ msgid "There are several known renderer types available in QGIS core library:"
#~ msgstr ""

#~ msgid ":class:`QgsSingleSymbolRendererV2`"
#~ msgstr ""

#~ msgid ":class:`QgsCategorizedSymbolRendererV2`"
#~ msgstr ""

#~ msgid ":class:`QgsGraduatedSymbolRendererV2`"
#~ msgstr ""

#~ msgid ""
#~ "There might be also some custom renderer types, so never make an assumption "
#~ "there are just these types. You can query :class:`QgsRendererV2Registry` "
#~ "singleton to find out currently available renderers:"
#~ msgstr ""

#~ msgid ""
#~ "You can get the symbol used for rendering by calling :func:`symbol` method "
#~ "and change it with :func:`setSymbol` method (note for C++ devs: the renderer"
#~ " takes ownership of the symbol.)"
#~ msgstr ""

#~ msgid ""
#~ "You can change the symbol used by a particular vector layer by calling "
#~ ":func:`setSymbol()` passing an instance of the appropriate symbol instance. "
#~ "Symbols for *point*, *line* and *polygon* layers can be created by calling "
#~ "the :func:`createSimple` function of the corresponding classes "
#~ ":class:`QgsMarkerSymbolV2`, :class:`QgsLineSymbolV2` and "
#~ ":class:`QgsFillSymbolV2`."
#~ msgstr ""

#~ msgid ""
#~ "The dictionary passed to :func:`createSimple` sets the style properties of "
#~ "the symbol."
#~ msgstr ""

#~ msgid ""
#~ "For example you can replace the symbol used by a particular **point** layer "
#~ "by calling :func:`setSymbol()` passing an instance of a "
#~ ":class:`QgsMarkerSymbolV2` as in the following code example:"
#~ msgstr ""

#~ msgid ""
#~ "To get the full list of properties for the first symbol layer of a simbol "
#~ "instance you can follow the example code:"
#~ msgstr ""

#~ msgid ""
#~ "You can query and set attribute name which is used for classification: use "
#~ ":func:`classAttribute` and :func:`setClassAttribute` methods."
#~ msgstr ""

#~ msgid ""
#~ "Where :func:`value` is the value used for discrimination between categories,"
#~ " :func:`label` is a text used for category description and :func:`symbol` "
#~ "method returns assigned symbol."
#~ msgstr ""

#~ msgid ""
#~ "The renderer usually stores also original symbol and color ramp which were "
#~ "used for the classification: :func:`sourceColorRamp` and "
#~ ":func:`sourceSymbol` methods."
#~ msgstr ""

#~ msgid ""
#~ "For representation of symbols, there is :class:`QgsSymbolV2` base class with"
#~ " three derived classes:"
#~ msgstr ""

#~ msgid ":class:`QgsMarkerSymbolV2` --- for point features"
#~ msgstr ""

#~ msgid ":class:`QgsLineSymbolV2` --- for line features"
#~ msgstr ""

#~ msgid ":class:`QgsFillSymbolV2` --- for polygon features"
#~ msgstr ""

#~ msgid ""
#~ "**Every symbol consists of one or more symbol layers** (classes derived from"
#~ " :class:`QgsSymbolLayerV2`). The symbol layers do the actual rendering, the "
#~ "symbol class itself serves only as a container for the symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "Having an instance of a symbol (e.g. from a renderer), it is possible to "
#~ "explore it: :func:`type` method says whether it is a marker, line or fill "
#~ "symbol. There is a :func:`dump` method which returns a brief description of "
#~ "the symbol. To get a list of symbol layers"
#~ msgstr ""

#~ msgid ""
#~ "To find out symbol's color use :func:`color` method and :func:`setColor` to "
#~ "change its color. With marker symbols additionally you can query for the "
#~ "symbol size and rotation with :func:`size` and :func:`angle` methods, for "
#~ "line symbols there is :func:`width` method returning line width."
#~ msgstr ""

#~ msgid ""
#~ "As said before, symbol layers (subclasses of :class:`QgsSymbolLayerV2`) "
#~ "determine the appearance of the features.  There are several basic symbol "
#~ "layer classes for general use. It is possible to implement new symbol layer "
#~ "types and thus arbitrarily customize how features will be rendered. The "
#~ ":func:`layerType` method uniquely identifies the symbol layer class --- the "
#~ "basic and default ones are SimpleMarker, SimpleLine and SimpleFill symbol "
#~ "layers types."
#~ msgstr ""

#~ msgid ""
#~ "You can get a complete list of the types of symbol layers you can create for"
#~ " a given symbol layer class like this"
#~ msgstr ""

#~ msgid "Output"
#~ msgstr ""

#~ msgid ""
#~ ":class:`QgsSymbolLayerV2Registry` class manages a database of all available "
#~ "symbol layer types."
#~ msgstr ""

#~ msgid ""
#~ "To access symbol layer data, use its :func:`properties` method that returns "
#~ "a key-value dictionary of properties which determine the appearance. Each "
#~ "symbol layer type has a specific set of properties that it uses. "
#~ "Additionally, there are generic methods :func:`color`, :func:`size`, "
#~ ":func:`angle`, :func:`width` with their setter counterparts. Of course size "
#~ "and angle is available only for marker symbol layers and width for line "
#~ "symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "The :func:`layerType` method determines the name of the symbol layer, it has"
#~ " to be unique among all symbol layers. Properties are used for persistence "
#~ "of attributes. :func:`clone` method must return a copy of the symbol layer "
#~ "with all attributes being exactly the same. Finally there are rendering "
#~ "methods: :func:`startRender` is called before rendering first feature, "
#~ ":func:`stopRender` when rendering is done. And :func:`renderPoint` method "
#~ "which does the rendering. The coordinates of the point(s) are already "
#~ "transformed to the output coordinates."
#~ msgstr ""

#~ msgid ""
#~ "For polylines and polygons the only difference would be in the rendering "
#~ "method: you would use :func:`renderPolyline` which receives a list of lines,"
#~ " resp. :func:`renderPolygon` which receives list of points on outer ring as "
#~ "a first parameter and a list of inner rings (or None) as a second parameter."
#~ msgstr ""

#~ msgid ""
#~ "You should pass layer type (the same as returned by the layer) and symbol "
#~ "type (marker/line/fill) to the constructor of parent class. "
#~ ":func:`createSymbolLayer` takes care of creating an instance of symbol layer"
#~ " with attributes specified in the `props` dictionary. (Beware, the keys are "
#~ "QString instances, not \"str\" objects). And there is "
#~ ":func:`createSymbolLayerWidget` method which returns settings widget for "
#~ "this symbol layer type."
#~ msgstr ""

#~ msgid ""
#~ "The constructor of parent :class:`QgsFeatureRendererV2` class needs renderer"
#~ " name (has to be unique among renderers). :func:`symbolForFeature` method is"
#~ " the one that decides what symbol will be used for a particular feature. "
#~ ":func:`startRender` and :func:`stopRender` take care of "
#~ "initialization/finalization of symbol rendering. :func:`usedAttributes` "
#~ "method can return a list of field names that renderer expects to be present."
#~ " Finally :func:`clone` function should return a copy of the renderer."
#~ msgstr ""

#~ msgid ""
#~ "Like with symbol layers, it is possible to attach a GUI for configuration of"
#~ " the renderer. It has to be derived from :class:`QgsRendererV2Widget`. The "
#~ "following sample code creates a button that allows user to set symbol of the"
#~ " first symbol"
#~ msgstr ""

#~ msgid ""
#~ "The constructor receives instances of the active layer "
#~ "(:class:`QgsVectorLayer`), the global style (:class:`QgsStyleV2`) and "
#~ "current renderer. If there is no renderer or the renderer has different "
#~ "type, it will be replaced with our new renderer, otherwise we will use the "
#~ "current renderer (which has already the type we need). The widget contents "
#~ "should be updated to show current state of the renderer. When the renderer "
#~ "dialog is accepted, widget's :func:`renderer` method is called to get the "
#~ "current renderer --- it will be assigned to the layer."
#~ msgstr ""

#~ msgid ""
#~ "To associate an icon with the renderer you can assign it in "
#~ ":class:`QgsRendererV2AbstractMetadata` constructor as a third (optional) "
#~ "argument --- the base class constructor in the RandomRendererMetadata "
#~ ":func:`__init__` function becomes"
#~ msgstr ""

#~ msgid ""
#~ "The icon can be associated also at any later time using :func:`setIcon` "
#~ "method of the metadata class. The icon can be loaded from a file (as shown "
#~ "above) or can be loaded from a `Qt resource "
#~ "<http://qt.nokia.com/doc/4.5/resources.html>`_ (PyQt4 includes .qrc compiler"
#~ " for Python)."
#~ msgstr ""

#~ msgid "working with style (:class:`QgsStyleV2`)"
#~ msgstr ""

#~ msgid "working with color ramps (:class:`QgsVectorColorRampV2`)"
#~ msgstr ""

#~ msgid ""
#~ "rule-based renderer (see `this blogpost <http://snorf.net/blog/2014/03/04"
#~ "/symbology-of-vector-layers-in-qgis-python-plugins>`_)"
#~ msgstr ""

#~ msgid "Here is how you can use the the undo functionality:"
#~ msgstr ""

#~ msgid ""
#~ "add features to index --- index takes :class:`QgsFeature "
#~ "<qgis.core.QgsFeature>` object and adds it to the internal data structure. "
#~ "You can create the object manually or use one from a previous call to "
#~ "provider's :meth:`nextFeature() "
#~ "<qgis.core.QgsVectorDataProvider.nextFeature>`"
#~ msgstr ""

#~ msgid "From an instance of :class:`QgsVectorFileWriter`"
#~ msgstr ""

#~ msgid ""
#~ "The third parameter specifies output text encoding. Only some drivers need "
#~ "this for correct operation (Shapefile is one of those), but if you are not "
#~ "using international characters you do not have to care much about the "
#~ "encoding."
#~ msgstr ""

#~ msgid ""
#~ "The fourth parameter that we left as ``None`` may specify the destination "
#~ "CRS --- if a valid instance of :class:`QgsCoordinateReferenceSystem "
#~ "<qgis.core.QgsCoordinateReferenceSystem>` is passed, the layer is "
#~ "transformed to that CRS."
#~ msgstr ""

#~ msgid ""
#~ "For valid driver names please consult the `supported formats by OGR`_ --- "
#~ "you should pass the value in the \"Code\" column as the driver name. "
#~ "Optionally you can set whether to export only selected features, pass "
#~ "further driver-specific options for creation or tell the writer not to "
#~ "create attributes --- look into the documentation for full syntax."
#~ msgstr ""

#~ msgid "From an instance of :class:`QgsVectorLayer`"
#~ msgstr ""

#~ msgid ""
#~ "you can again use :func:`classAttribute` to find out classification "
#~ "attribute name, :func:`sourceSymbol` and :func:`sourceColorRamp` methods.  "
#~ "Additionally there is :func:`mode` method which determines how the ranges "
#~ "were created: using equal intervals, quantiles or some other method."
#~ msgstr ""

#~ msgid ""
#~ "Having an instance of a symbol (e.g. from a renderer), it is possible to "
#~ "explore it: :meth:`type <qgis.core.QgsSymbol.type>` method says whether it "
#~ "is a marker, line or fill symbol. There is a :meth:`dump "
#~ "<qgis.core.QgsSymbol.dump>` method which returns a brief description of the "
#~ "symbol. To get a list of symbol layers:"
#~ msgstr ""

#~ msgid ""
#~ "To find out symbol's color use :meth:`color <qgis.core.QgsSymbol.color>` "
#~ "method and :meth:`setColor <qgis.core.QgsSymbol.setColor>` to change its "
#~ "color. With marker symbols additionally you can query for the symbol size "
#~ "and rotation with :meth:`size <qgis.core.QgsSymbol.size>` and :meth:`angle "
#~ "<qgis.core.QgsSymbol.angle>` methods, for line symbols there is :meth:`width"
#~ " <qgis.core.QgsSymbol.width>` method returning line width."
#~ msgstr ""

#~ msgid ""
#~ ":class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` class "
#~ "manages a database of all available"
#~ msgstr ""

#~ msgid "symbol layer types."
#~ msgstr ""

#~ msgid ""
#~ "To access symbol layer data, use its :meth:`properties() "
#~ "<qgis.core.QgsSymbolLayer.properties>` method that returns a key-value "
#~ "dictionary of properties which determine the appearance. Each symbol layer "
#~ "type has a specific set of properties that it uses. Additionally, there are "
#~ "generic methods :meth:`color <qgis.core.QgsSymbol.color>`, :meth:`size "
#~ "<qgis.core.QgsSymbol.size>`, :meth:`angle <qgis.core.QgsSymbol.angle>`, "
#~ ":meth:`width <qgis.core.QgsSymbol.width>` with their setter counterparts. Of"
#~ " course size and angle is available only for marker symbol layers and width "
#~ "for line symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "The :meth:`layerType <qgis.core.QgsMarkerSymbolLayer.layerType>` method "
#~ "determines the name of the symbol layer, it has to be unique among all "
#~ "symbol layers. Properties are used for persistence of attributes. "
#~ ":meth:`clone <qgis.core.QgsMarkerSymbolLayer.clone>` method must return a "
#~ "copy of the symbol layer with all attributes being exactly the same. Finally"
#~ " there are rendering methods: :meth:`startRender "
#~ "<qgis.core.QgsMarkerSymbolLayer.startRender>` is called before rendering "
#~ "first feature, :meth:`stopRender "
#~ "<qgis.core.QgsMarkerSymbolLayer.stopRender>` when rendering is done. And "
#~ ":meth:`renderPoint <qgis.core.QgsMarkerSymbolLayer.renderPoint>` method "
#~ "which does the rendering. The coordinates of the point(s) are already "
#~ "transformed to the output coordinates."
#~ msgstr ""

#~ msgid ""
#~ "For polylines and polygons the only difference would be in the rendering "
#~ "method: you would use :meth:`renderPolyline "
#~ "<qgis.core.QgsMarkerSymbolLayer.renderPolyline>` which receives a list of "
#~ "lines, while :meth:`renderPolygon "
#~ "<qgis.core.QgsMarkerSymbolLayer.renderPolygon>` receives list of points on "
#~ "outer ring as a first parameter and a list of inner rings (or None) as a "
#~ "second parameter."
#~ msgstr ""

#~ msgid ""
#~ "This widget can be embedded into the symbol properties dialog. When the "
#~ "symbol layer type is selected in symbol properties dialog, it creates an "
#~ "instance of the symbol layer and an instance of the symbol layer widget. "
#~ "Then it calls :func:`setSymbolLayer` method to assign the symbol layer to "
#~ "the widget. In that method the widget should update the UI to reflect the "
#~ "attributes of the symbol layer. :func:`symbolLayer` function is used to "
#~ "retrieve the symbol layer again by the properties dialog to use it for the "
#~ "symbol."
#~ msgstr ""

#~ msgid ""
#~ "On every change of attributes, the widget should emit :func:`changed()` "
#~ "signal to let the properties dialog update the symbol preview."
#~ msgstr ""

#~ msgid ""
#~ "You should pass layer type (the same as returned by the layer) and symbol "
#~ "type (marker/line/fill) to the constructor of parent class. "
#~ ":meth:`createSymbolLayer() "
#~ "<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` takes care of "
#~ "creating an instance of symbol layer with attributes specified in the "
#~ "`props` dictionary. And there is :meth:`createSymbolLayerWidget() "
#~ "<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` method "
#~ "which returns settings widget for this symbol layer type."
#~ msgstr ""

#~ msgid ""
#~ "The constructor of parent :class:`QgsFeatureRenderer` class needs a renderer"
#~ " name (which has to be unique among renderers). The :func:`symbolForFeature`"
#~ " method is the one that decides what symbol will be used for a particular "
#~ "feature. :func:`startRender` and :func:`stopRender` take care of "
#~ "initialization/finalization of symbol rendering. The :func:`usedAttributes` "
#~ "method can return a list of field names that renderer expects to be present."
#~ " Finally, the :func:`clone` function should return a copy of the renderer."
#~ msgstr ""

#~ msgid ""
#~ "Like with symbol layers, it is possible to attach a GUI for configuration of"
#~ " the renderer. It has to be derived from :class:`QgsRendererWidget`. The "
#~ "following sample code creates a button that allows user to set symbol of the"
#~ " first symbol"
#~ msgstr ""

#~ msgid ""
#~ "The constructor receives instances of the active layer "
#~ "(:class:`QgsVectorLayer`), the global style (:class:`QgsStyle`) and current "
#~ "renderer. If there is no renderer or the renderer has different type, it "
#~ "will be replaced with our new renderer, otherwise we will use the current "
#~ "renderer (which has already the type we need). The widget contents should be"
#~ " updated to show current state of the renderer. When the renderer dialog is "
#~ "accepted, widget's :func:`renderer` method is called to get the current "
#~ "renderer --- it will be assigned to the layer."
#~ msgstr ""

#~ msgid ""
#~ "Similarly as with symbol layers, abstract metadata constructor awaits "
#~ "renderer name, name visible for users and optionally name of renderer's "
#~ "icon. :func:`createRenderer` method passes :class:`QDomElement` instance "
#~ "that can be used to restore renderer's state from DOM tree. "
#~ ":func:`createRendererWidget` method creates the configuration widget. It "
#~ "does not have to be present or can return `None` if the renderer does not "
#~ "come with GUI."
#~ msgstr ""

#~ msgid ""
#~ "To associate an icon with the renderer you can assign it in "
#~ ":class:`QgsRendererAbstractMetadata` constructor as a third (optional) "
#~ "argument --- the base class constructor in the RandomRendererMetadata "
#~ ":func:`__init__` function becomes"
#~ msgstr ""

#~ msgid ""
#~ "The icon can be associated also at any later time using :func:`setIcon` "
#~ "method of the metadata class. The icon can be loaded from a file (as shown "
#~ "above) or can be loaded from a `Qt resource "
#~ "<https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 includes .qrc compiler for "
#~ "Python)."
#~ msgstr ""

#~ msgid "|outofdate|"
#~ msgstr ""

#~ msgid ""
#~ "The constructor also takes a URI defining the geometry type of the layer, "
#~ "one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
#~ "``\"MultiPoint\"``, ``\"MultiLineString\"``, or ``\"MultiPolygon\"``."
#~ msgstr ""
